<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>이계영</author>
    <comments/>
    <content>By Allen Holub&#xD;
&#xD;
Is design possible in the "real world?"&#xD;
&#xD;
I just finished a series of articles on UI design for JavaWorld magazine (www.javaworld.com) and though the feedback was about 20:1 positive, I did receive an interesting post from Richard Pitts, an excerpt from which should initiate what I hope will be a fertile discussion. Here's what Richard had to say: &#xD;
&#xD;
&#xD;
&#xD;
To pursue "a well-crafted object-oriented system" only distracts a developer from the true purpose of the system they are developing. I actually saw ...a very high profile, multimillion dollar project got way off track and eventually cancelled because it was run by two object-oriented purists. They spent all their time trying to develop the perfect class library that was to be the foundation upon which all the "real" development was based. But after 18 months they could not demonstrate a single screen or report to management. They completely lost sight of the system they were supposed to be developing -- the "real" goal. &#xD;
While you and other like-minded people wallow in your theoretical discussion on the one "right" way to develop software, millions of us other developers are delivering solutions to the end-user. &#xD;
&#xD;
&#xD;
Let me start out by saying that I'm a firm believer in both design and process within a software organization. My personal experience is that a very formal environment coupled with good design can dramatically improve the overall productivity of a software organization. If you don't believe me, IEEE Software ran a compelling article a few years back that documented Motorola's experience in moving from a standard helter-skelter software-development model to a very formal model that involved lots of up-front design work and high "ceremony" (ongoing paperwork). (See "How Software Process Improvement Helped Motorola," IEEE Software 14:5 [September/October, 1997; pp. 75&amp;#8211;81].) &#xD;
&#xD;
When you compare what was happening at the beginning and end of the adoption process, overall productivity increased by a factor of three. When the adoption was complete, programmers at Motorola were developing code roughly eight times faster, with 80 percent fewer bugs. These are not numbers to sneeze at. The plain fact is that solid design and good process not only help you get a product to market faster, but that product will also be of higher quality and more usable. I don't know of a goal more "real" than that. On average, every hour you spend in design reduces coding &#xD;
and debugging time by about eight hours. I often hear the statement "in the real world, we don't have time to design." I strongly believe that in the real "real world" of harsh deadlines and time-to-market pressure, you don't&#xD;
have time not to design. &#xD;
&#xD;
I too once witnessed a multimillion dollar project fail, but it wasn't because design in general is a bad thing; it was because the design itself was poor, and put together without any formal process (including external review -- I was the first outsider to look at the project, a year and a &#xD;
half after it had started). There are a lot of bad designers out there, and Richard's designers seem to have made a classic mistake: they tried to design a class hierarchy in a vacuum. &#xD;
&#xD;
The OO design process is a formal process, composed of three essential parts: &#xD;
&#xD;
Requirements gathering and use-case modeling &#xD;
&#xD;
Static modeling (modeling all the relationships between classes in the system) &#xD;
&#xD;
Dynamic modeling (designing the objects in the system and the messages they send back to each other at runtime) &#xD;
&#xD;
 &#xD;
Once all that is complete, you code. &#xD;
&#xD;
Knowing when to stop the modeling process is also important, and my guess is that Richard's designers were overdesigning. A good analogy is the architecture of a building: the plans for a house will show you where the &#xD;
electrical outlets and switches are, but not how to route the wires. &#xD;
They'll show you where the walls go, but not how to build a wall. &#xD;
&#xD;
Some people think (incorrectly) that a design must show the software equivalent of every stud, every wire, and every nail, but that's nonsense. You stop at the point where any competent programmer could implement. &#xD;
Richard's experience is unusual in that I've found that most project's fail not because of too much design, but rather because coding started too soon. &#xD;
</content>
    <postId>B9114273-07A1-4CDD-98D6-72578DB95E3C</postId>
    <pubDate>2002-08-01T00:00:00-04:00</pubDate>
    <title>Is design possible in the Real world(Good OO design)</title>
</post>
