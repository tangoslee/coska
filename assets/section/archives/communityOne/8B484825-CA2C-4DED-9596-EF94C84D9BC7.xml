<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>황성규</author>
    <comments/>
    <content>The magic of Merlin &#xD;
How the new JDK 1.4 -- code-named Merlin -- levitates its functionality &#xD;
&#xD;
Summary&#xD;
This technical overview will give you insight into the various new features and APIs of the upcoming JDK 1.4 -- code-named Merlin -- expected to be released this month. (3,000 words) &#xD;
By Vinay Aggarwal &#xD;
&#xD;
Sun Microsystems has promised a 12- to 18-month time frame for each major release of the JDK. Sticking to its promise, Sun plans to unveil JDK 1.4 -- code-named Merlin -- this March. The Java Community Process (JCP) has been working on the release for more than a year. The coolest thing about this release is that the JCP allows its users to actively participate in deciding the features and the direction that Java should take. Merlin was developed under Java Specification Request (JSR) 59. &#xD;
&#xD;
According to Merlin's JSR, the release is focused on reliability, serviceability, scalability, performance, and deployment. I define it as a focus on building "maintainable software." It will include many new APIs with added functionality, for which we had to use third-party APIs in the past. Getting those APIs bundled with JDK will standardize them; that will reduce software development time and maintenance costs. I will talk about those APIs shortly. Merlin's final feature set is not yet public, so some of the features discussed in this article might not appear in the final release. &#xD;
&#xD;
I've used various JSRs on the JCP Website as resources for this article. If you're already familiar with these JSRs -- such as JSR 59 Merlin release contents, JSR 54 JDBC 3.0 Specification, and JSR 31 XML Data Binding Specification -- you already have a head start. Otherwise, I strongly recommend that you check out the JCP Website. JSRs not only tell you what is coming in a new release (thus giving you a market advantage), but also allow you to participate in the Java development. (See Resources for more information.) &#xD;
&#xD;
XML &#xD;
XML is already an essential part of Java and the Web. Java and XML will likely be more closely connected in the future, as XML complements Java nicely. XML parsers with DOM and SAX APIs are already available on Sun's Website. (See Resources.) Version 2.0 of those parsers is under development and will be bundled with Merlin. The JDOM API will not be supported; instead, a new specification called XML Data Binding is under development and will be shipped with Merlin. XML Data Binding is much more powerful than JDOM; it is a combination of powerful document definition and corresponding XML parsing and data validation. &#xD;
&#xD;
As of today, document type definition (DTD) is a widely used mechanism for XML validation. DTD has a few limitations; for example, you cannot specify that a string can only be 10 to 13 characters long. DTD was a quick fix to a nonexistent validation mechanism. Now with experience and time, the World Wide Web Consortium (W3C) has come up with a new recommendation called XML Schema. It is a more elaborate and flexible mechanism to validate an XML document. Technically, you can write a set of classes that represent the XML Schema. Those classes can parse, load, and validate the XML document and create Java objects for nodes, which you can use directly in your Java programs. XML Data Binding is just a mechanism to generate those classes automatically for any given XML Schema. With XML Data Binding, all the code that was required to parse the XML and extract the meaningful objects will not be required. Sun's work on XML Data Binding is also known as Project Adelard. (See Todd Sunsted's "Adelard, One Year Later" (JavaOne Today, June 2000).) &#xD;
&#xD;
Logging API &#xD;
Companies are becoming more aware that fixing a software defect during deployment can be up to 100 times more costly than fixing it during development. Hence, is it not only important to build the software the right way, but also to provide hooks and tools to trace problems in released software. Logging is an important part of building maintainable software. Today, many logging APIs exist, but they are not standardized, and few developers make the effort to evaluate and use them. Some developers tend to write their own logging APIs, which generally are buggy, nonoptimized, and nonextensible. Merlin solves those problems by including a built-in logging API. &#xD;
&#xD;
The new logging API offers no surprises. It is based on well-known concepts of priorities, filters, formatters, and handlers. You call the logging module with the message and a priority (like "WARNING" or "SEVERE") for the message. The message passes through filters that decide (based on configuration) if the given priority message should be logged or discarded. The formatter formats the message string -- it adds time stamp, thread stamp, exception stack trace, and so on (again based on current configuration). The handlers are responsible for writing the log message to the output device -- such as a file, socket, or database. You can create your own filters, formatters, and handlers and plug them into the framework. The API provides a complete set of functionalities required for most projects. If needed, you can build more complicated mechanisms on top of this framework. &#xD;
&#xD;
JDBC 3.0 &#xD;
JDBC 1.0 -- introduced with JDK 1.1 -- had minimal database functionality. JDK 1.2 delivered JDBC 2.0, which contained enhanced features like scrollable result sets, batch updates, BLOB and CLOB support, ARRAY type, user defined types (UDTs), structured types, and distinct types. Then came the development of the JDBC 2.0 optional package: a standard extension that provides the DataSource class (which uses JNDI to connect to any kind of data, such as flat files or spreadsheets), connection pooling, distributed transactions, and RowSets (a higher-level interface on top of ResultSet). &#xD;
&#xD;
For its part, Merlin has major JDBC changes in store. It is being bundled with JDBC 3.0, whose complete feature set would take another article to describe. If you want more detailed information than this article provides, see Resources. &#xD;
&#xD;
JDBC 3.0 contains the JDBC 2.0 classes and the JDBC optional package classes. That means the optional package is being merged into standard JDBC, making the Java platform more flexible and complete. The SQL99 standard has also been finalized, so JDBC 3.0 will also attempt to be consistent with that standard. JDBC 3.0 will not support the whole SQL99, but the features that are implemented will be consistent with the standard. &#xD;
&#xD;
A mechanism for connecting JDBC with a connector architecture using the Service Provider Interface (SPI) is also in the works. The connector architecture is a general way to connect to enterprise information systems (EIS), such as ERP systems, mainframe transaction processing systems, and hierarchical databases. The connector architecture specification defines a set of contracts that allow a resource adapter to extend a container in a pluggable way. &#xD;
&#xD;
Three new row sets have been implemented. JDBCRowSet makes the JDBC driver look like a JavaBean component. You can use it to make JDBC applications with GUI tools. CachedRowSet loads the data into a cache and disconnects the SQL connection from the database. Hence, you can pass that cached row set between tiers of the application. It also helps to optimize the database connections. Any changes made to the cached data can later be reflected back into the database. WebRowSet lets you convert JDBC data (with its properties and metadata) to XML, which you can use anywhere. You can also convert the XML back to data and save any data changes back to the database. This will be very useful with upcoming XML communication protocols and tools. You can also use custom readers and writers with these row sets to provide your own mechanisms to read and write data. For instance, you can provide custom mechanisms to read data from a nonrelational database or you can provide your own conflict-resolution mechanism while saving data. &#xD;
&#xD;
Other features of JDBC 3.0 include: &#xD;
&#xD;
&#xD;
Savepoint support (the ability to roll back transactions to designated savepoints) &#xD;
Connection pool configurations (added properties to describe how PooledConnection objects should be pooled) &#xD;
Reuse of prepared statements with connection pools (in JDK 1.3, when you close a SQL connection, the prepared statement dies with it, but now the statement will be independent) &#xD;
Retrieval of parameter metadata (the new interface ParameterMetaData describes the number, type, and properties of parameters to prepared statements) &#xD;
Retrieval of auto-generated key columns &#xD;
Multiple open result sets on a statement &#xD;
BOOLEAN data type &#xD;
DATALINK data type (allows JDBC drivers to store and retrieve references to external data) &#xD;
Updateable BLOB, CLOB, ARRAY, and Ref objects &#xD;
Transform groups and type mapping (defines how UDT can be transformed to a predefined SQL type and how that is reflected in metadata) &#xD;
DatabaseMetaData APIs that retrieve SQL type hierarchies &#xD;
&#xD;
Security &#xD;
Also bundled in the new release is the optional Java Secure Socket Extension (JSSE) package. JSSE implements Secure Socket Layer (SSL) and Transport Layer Security (TLS) protocols. It is currently available for download as an extension. (See Resources.) &#xD;
&#xD;
Java Authentication and Authorization Service (JAAS) is a new API that lets you establish access control on a per-user basis. JAAS is incredibly useful; for example, you can use it in situations when an administrator needs more menus and options than a normal user. &#xD;
&#xD;
Java Cryptography Extension (JCE) is another standard extension that will be bundled with Merlin. JCE provides functionality for encryption, key generation and key agreement, and message authentication code (MAC). Fortunately, JCE can now be exported from the US and Canada because of more lenient security regulations. Now, applications that use cryptography can be exported, so people in other countries can benefit from the Cryptography API. That means only the policy files that define the cryptographic strength are altered; then the application can be exported to international customers. Public Key Cryptography Standards (PKCS) support is also being finalized. &#xD;
&#xD;
A reference implementation for the Certification Path Building and Verification API is already under way. This will allow access to certificates (and hence, public keys) via LDAP/JNDI. This benefits applications that need to deal with SSL, signed code, S/MIME, and so forth. &#xD;
&#xD;
Preferences API &#xD;
Most applications need to store preferences and configurations. Those settings are generally stored in properties files that are not very elegant to work with. Sometimes, if the user base is very large, user preferences are also stored in an LDAP/RDBMS. These mechanisms are also not totally reliable; for example, if you store configurations in a properties file, where do you keep that properties file? Similarly, if you store them in an LDAP/RDBMS, where do you keep the connection parameters for the LDAP/RDBMS? &#xD;
&#xD;
Hence, a new preferences API was developed; it will provide a mechanism to store application-wide configuration as well as per-user settings. Not many details about this API are available -- we will have to wait and see. It seems unlikely that the preferences API will be completed in time for the Merlin release. &#xD;
&#xD;
Assertions &#xD;
Java code will be easier to debug, thanks to upcoming assertions. Assertions were supposed to be included at the time of JDK 1.0, but were dropped due to time constraints. Using assertions, you can provide various checkpoints in the application to validate data or the application's state. If an assertion fails, an AssertionError is thrown. A new keyword called assert will be added to the Java language. Assertions are generally used for developing software; hence, Merlin provides hooks so you can disable the assertions when your software is put into production. This will cause minimal or no overhead on the software's deployed version. You can enable or disable assertions dynamically by calling a method on ClassLoader. You can also change the assertion status on a per-package, or even per-class, basis. Assertions are meant to be a development tool and can be disabled, so you should keep in mind that assertions should not change the state of the system; for example, calling counter++ in an assert statement is a poor coding practice. &#xD;
&#xD;
RMI &#xD;
You will also find custom remote reference support in the RMI protocol. This will let you implement your own remote objects; for example, you can write your own remote object (like UnicastRemoteObject or Activatable) and use it over the standard RMI protocol. Since you'll define how the objects communicate, you can provide your own communication mechanism, like non-TCP-based communication or some custom secure communication. &#xD;
&#xD;
RMI will allow more control of the codebase annotation so that multiple services running within a single VM can have separate codebases. &#xD;
&#xD;
Security enhancements in RMI will allow a client and server to mutually authenticate each other. This adds security to the architecture and allows the server to execute code on behalf of the client (with the client's security). &#xD;
&#xD;
CORBA &#xD;
CORBA enhancements include a portable object adapter (POA), which will allow transparent plug-in of any vendor's ORB implementation. It will also support server activation and object persistency. Portable interceptor APIs are also being developed, which will allow custom code to plug into the ORB. Portable interceptors will make it possible to run the J2EE Reference Implementation with any vendor's ORB. &#xD;
&#xD;
Java Platform Debugger Architecture &#xD;
The Java Platform Debugger Architecture (JPDA) will include new functionality that will let you reload any class in a running system. As of today, every time a class file changes, the application has to be shut down and restarted before the system acknowledges the change. That is time-consuming, reduces productivity, and is very annoying, especially during development. Many vendors use custom hooks to unload classes, but they will no longer be required in Merlin. &#xD;
&#xD;
Miscellaneous new features &#xD;
Merlin introduces other new features that I'd like to cover briefly. &#xD;
&#xD;
JNDI and LDAP &#xD;
A DNS service provider for JNDI is being implemented into Merlin. You can use the provider to do hostname lookups with JNDI. &#xD;
&#xD;
Support for Directory Services Markup Language (DSML) is also being added. DSML is a markup language for representing directory data in XML. That essentially means that you can create an XML hierarchy for any JNDI service provider. For example, you can get a list of files and folders as an XML hierarchy, or you can get LDAP data as an XML hierarchy. That feature will be very useful as more tools and products become XML-aware, and XML communication protocols become the preferred way to exchange data. &#xD;
&#xD;
You can already access Windows 2000's active directory from Java using LDAP with simple authentication. A new authentication mechanism is underway -- it will provide a GSS-SPNEGO/Kerberos V5 SASL authentication mechanism for LDAP access to an active directory. &#xD;
&#xD;
I/O and exceptions &#xD;
A new API is being developed for scalable input/output (I/O) operations. It is designed to be scalable for file and socket I/O and to take advantage of multiple processors in a multiprocessor machine. To make I/O scalable, the API (not yet named) will allow asynchronous requests or polling for file and socket I/O. This is especially useful for Internet applications where hundreds of thousands of users access data simultaneously. &#xD;
&#xD;
In addition, regular expressions-based text scanning and printing functionality will be provided. This functionality matches the printf function in C, and will make it easy to format text output. &#xD;
&#xD;
Chaining of exceptions is another small but very important addition. SQLException already has this functionality. If a database error occurs, the driver throws SQLException. But now you can call getNextException() in SQLException to see the exact low-level exception thrown. Thus, you get the abstraction from low-level exceptions, but you can still drill down to the lowest level and find the exact cause of the problem. This functionality will now be supported by the standard java.lang.Exception. &#xD;
&#xD;
Swing &#xD;
Swing will now have default drag-and-drop support on JList, JText, JTree, JLabel, and JTable. A new component called Spinner is being added. Spinner is a standard control in which up and down arrow buttons are provided with a text box. The text box can have numeric values only, and the values can be increased or decreased with up or down arrow keys, respectively. JTabbedPane will now allow one row of tabs to have scroll capability, in case all the tabs do not fit on the screen. Macintosh look and feel will have the global menu bar at the top. Windows 2000 look and feel is also underway. &#xD;
&#xD;
In addition, file dialogs will more closely resemble the native windowing environment and provide a much-needed default filename filter. And you can now drag and drop all supported mime types data between JVM and native platforms. &#xD;
&#xD;
Java Virtual Machine &#xD;
The latest JDK will have 64-bit support for Solaris, Linux, and Windows. Sun is also working on providing class-sharing capabilities across VMs running on the same system. That would help reduce a running system's memory footprint. Other improvements include faster class loading and better fault tolerance. &#xD;
&#xD;
Networking &#xD;
Merlin will support IPv6, the next-generation Internet Protocol, which will provide 2128 unique IP addresses compared to the current 232 addresses. SocketFactory classes will be introduced, along with disconnected sockets and tunneled sockets. Sockets will also support ICMP and RAW connections now. A pure Java-based DNS service will also be provided. &#xD;
&#xD;
Headless Java &#xD;
Headless Java will let Java programs run even if the windowing system is not available. This is difficult to perceive in the Microsoft Windows world, but in Unix it is common. &#xD;
&#xD;
And more... &#xD;
An improvement is made in Java 2D (and Swing) that renders speed with a new pipeline architecture. It also includes support for additional image I/O operations, such as animated GIF, TIFF formats, and improved Java 2D printing. &#xD;
&#xD;
Sun is also working on a dense jar-file format that will make jar files much smaller. That will be especially useful for Internet applications working on low bandwidth. &#xD;
&#xD;
Additional APIs are being added to help Java installers. These will typically include support for versioning information and checks for free disk space. &#xD;
&#xD;
Merlin makes improvements in internationalization as well, including Input Method Framework enhancements and Hindi language support. &#xD;
&#xD;
Conclusion &#xD;
I am anxiously awaiting Merlin's arrival; its new features will make my life, and yours, so much simpler. I hope the industry is quick to adapt the new JDK 1.4. Again, I encourage you to check the Java Community Process regularly and provide feedback on the specification. Your comments won't help Merlin at this point, but they will help Tiger -- the code name for the next JDK version. &#xD;
 &#xD;
</content>
    <postId>8B484825-CA2C-4DED-9596-EF94C84D9BC7</postId>
    <pubDate>2001-03-26T00:00:00-05:00</pubDate>
    <title>About JDK 1.4 !! - Cool!!   </title>
</post>
