<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>황성규</author>
    <comments/>
    <content>분산객체 기술의 주류를 넘보는 새로운 강자, EJB&#xD;
&#xD;
컴포넌트 기반 개발 환경에서 각광받고 있는 EJB는 버전 1.0에서 1.1로 1세대를 지나, 2.0으로 다시 태어날 예정이다. 자바 기술의 장점을 등에 엎고 주류 자리를 넘보는 EJB의 현재 모습을 스펙과 아키텍처 등을 중심으로 알아보고, XML과의 연동성, 다른 컴포넌트 기술과는 어떻게 연관되는지 심층 분석해 보자.&#xD;
&#xD;
유형열 이네트 전자상거래연구소&#xD;
&#xD;
&#xD;
--------------------------------------------------------------------------------&#xD;
&#xD;
최근한국 소프트웨어 컴포넌트 컨소시엄(www.component.or.kr) KCSC가 조사한 자료에 따르면 작년까지 만해도 분산객체기술의 45%를 COM/DCOM이 차지해 30%의 EJB(Enterprise JavaBeans)를 앞섰으나, 올해는 EJB가 56%로 33.3%의 COM/DCOM을 앞질렀다고 한다. 현재 COM/DCOM을 채택한 개발자들 중 상당수가 EJB를 새로 채택해 향후 EJB 채용의 증가가 예측된다고 전하고 있다. 이 자료를 보고 필자는 격세지감을 느낀다. 1년 전 만해도 EJB 관련 개발자가 드물었고, 개발자 대부분이 막 접근하는 단계였다. 인터넷 환경에서 자바 프로그래밍의 생산성과 편리성이 개발자와 시스템 관리자에게 부각되면서, 자바 컴포넌트인 EJB가 분산 환경의 트랜잭션 처리에 활용되기 시작했다. 따라서 개발자층은 두껍게 형성됐다. 1년 사이에 많은 프로젝트가 EJB를 적용했고, 그에 따라 개발자도 많은 경험과 기술을 축적했음을 짐작할 수 있다. EJB가 컴포넌트 시장에서 자리를 확고히 해가고 있음을 알 수 있다.&#xD;
&#xD;
자바 기술의 원류, EJB&#xD;
&#xD;
이런 현상은 많은 클라이언트/서버 환경에서 웹으로 전환하면서 웹 프로그래밍에 적합한 기술을 적용하는 데 있어 요구되는 사항을 자바가 잘 지원한다고 판단했기 때문으로 풀이된다, 실제로 미국의 실리콘밸리 GUI 개발 업체의 75%가 개발 언어로 자바를 선택한다고 한다. 이는 자바가 배우기 쉬운 문법, 개발의 용이성, 플랫폼에 의존적이지 않는 아키텍처 등의 장점을 갖고 있기 때문이다. 전자상거래, 전자화폐와 같이 웹 기반의 비즈니스 시대가 도래하면서 자바와 자바 관련 기술은 급속도로 발전하고 있다. 그럼, 자바 관련 기술이 빠르게 변하는데 개발자는 어떻게 대처해야 나갈 것인가? 물론 기술 흐름의 원류를 타야 한다. 그 원류의 한 복판에 EJB가 있다. EJB에서 많은 관련 기술을 끌어와 적용하기 때문이다.&#xD;
&#xD;
EJB 개발을 담당한 개발자나 지금 막 시작하려는 개발자가 궁금해하는 것과 이들에게 필요한 것은 무엇일까? 이 글에서는 EJB의 기본 개념부터 사용방법, 아키텍처, 트랜잭션, EJB 향후 모습 등을 독자와 나누도록 하겠다. 개괄적인 것과 개발자로서 심층적으로 알아야 할 것을 소개하고, EJB를 분산 환경에 적용할 수 있는 방법을 필자의 경험을 토대로 설명하도록 하겠다.&#xD;
&#xD;
EJB 워밍업&#xD;
&#xD;
EJB란 멀티 티어(multi-tier)의 분산형 객체지향 자바 애플리케이션을 개발하고, 보급하기 위한 컴포넌트 아키텍처다. 확장성있는 애플리케이션 서버 컴포넌트를 지원하는 여러 서비스를 제공함으로써 컴포넌트 단위로 비즈니스 애플리케이션을 쉽게 작성할 수 있다. 트랜잭션 처리 모니터(TP Monitor), 웹 서버, 데이터베이스 서버, 애플리케이션 서버 등과 같은 트랜잭션 처리 시스템에서 운영한다.&#xD;
&#xD;
컴포넌트 모델은 서버 컴포넌트를 지원하기 위해 스윙(Swing) 등의 자바빈 컴포넌트 모델을 확장한 것이다. 여기서 서버 컴포넌트란 애플리케이션 서버에서 실행한 애플리케이션 컴포넌트를 의미하고, 애플리케이션을 개발하기 위해 다른 컴포넌트와 결합할 수도 있다. EJB 컴포넌트는 자바빈 컴포넌트와 달리 시각적인 자바 IDE (Integrated Development Environment) 환경에서 조작할 수 없으며, 이름만 비슷할 뿐 전혀 관련이 없다. 이름이 비슷한 이유는 썬 마이크로시스템즈(이하 썬)가 마케팅 차원에서 같은 이름을 사용했기 때문이다. EJB는 J2EE(JAVA 2 Enterprise Edition)의 핵심으로 자리하며 J2EE 플랫폼 기반에서 개발자가 재사용할 수 있고, 이식성이 좋은 서버 사이드 비즈니스 로직을 작성하도록 지원한다.&#xD;
&#xD;
필자가 EJB 관련 개발자가 꼭 알아야 한다고 생각하는 것은 EJB는 제품이 아니라 아키텍처의 스펙이므로 EJB를 알고 적절하게 활용하려면 썬이 제공한 스펙을 꼭 마스터해야 한다. 스펙을 파악하면 EJB 아키텍처를 구현한 여러 제품의 차이와 유사점을 쉽게 구분할 수 있고, 업무에 따라 적절한 제품을 선택할 수 있다. 그리고 추후 보강될 부분이 비록 안(Draft)이지만 이미 배포돼 있으므로, EJB의 발전 모습도 쉽게 볼 수 있을 것이다. EJB의 주요 특징은 다음과 같다.&#xD;
&#xD;
전적으로 자바 프로그래밍 언어로 작성된 서버 사이드 컴포넌트이다 &#xD;
단지 비즈니스 로직만을 담고 있고, 시스템 레벨 프로그래밍은 없다. &#xD;
시스템 레벨 서비스(트랜잭션, 보안, 생명주기, 쓰레딩, 데이터 저장 등)는 자동으로 EJB 서버가 EJB 컴포넌트를 관리한다. &#xD;
EJB 아키텍처는 본질적으로 트랜잭션 처리와 분산 환경, 이식성 있으며, 멀티 티어로 확장할 수 있고 보안성이 높다. &#xD;
컴포넌트는 선언을 통해 커스터마이징된다. &#xD;
어떠한 EJB 서버, OS와도 전체적으로 이식할 수 있다.&#xD;
EJB를 왜 사용하는가?&#xD;
&#xD;
필자가 처음 자바를 접했을 때 느꼈던 기쁨과 달리, 프로젝트를 개발하면서 만난 EJB는 컴포넌트 개념을 갖고 접근하지 못해서인지 구미가 당기지 않았다. 시간이 지나 웹 프로그래밍이 분산 환경으로 흘러가고 소프트웨어 개발에서 방법론적 언어 UML(Unified Modeling Lan guage)을 배우면서 컴포넌트에 대한 눈을 조금씩 뜨게 됐다. 따라서 분산 환경에서 자바 프로그래밍을 할 때 EJB를 활용하면 생산성 향상에 좋겠다는 생각으로 가득찼다. 그럼 EJB의 어떤 특징 때문에 이렇게 생각했는지 설명하겠다.&#xD;
&#xD;
최 대리가 선택한 EJB의 장점&#xD;
&#xD;
박스 기사 속의 최 대리가 컴포넌트 개발 기술로 선택한 주요 이점은 다음과 같다.&#xD;
&#xD;
애플리케이션 개발 기간 단축 : 자바 기술의 생산성과 컴포넌트의 재사용, 아웃소싱, 개발자는 비즈니스 로직에만 초점을 맞추고, 프로그래밍을 수정하지 않고도 선언(배포 기술자, Deployment Descriptor)으로 커스터마이징할 수 있다. &#xD;
폭넓은 분야에 적용 가능 : 우수한 아키텍처를 만들기 위한 범산업적인 협력과 서버 선택이 필요없고, 서드파티 컴포넌트가 서버에 의존적이지 않다. &#xD;
애플리케이션 이식성 : 어디서나 작동하는 비즈니스 로직으로, 플랫폼과 미들웨어 독립적이다. &#xD;
벤더 비선택 : 아키텍처 결정 사항은 배포시에 만들어진다. &#xD;
서버간 이식성 : 어떤 EJB 서버에서도 코드를 배포할 수 있다. &#xD;
서버간 확장성 : 서버가 서비스 레벨, 성능, 보안에 따라 변경되더라도 투명하게 대체할 수 있다.&#xD;
이 특징들은 썬에서 강조하는 장점이다. 현실적으로 이 이점을 모두 누리기에는 개발 환경이 열악하다. 즉, 벤더 제품이 스펙을 준수하면서 구현시에 조금씩 차이를 두는 부분이 있고, J2EE를 사용해 각 버전간 차이로 인한 격차가 존재한다. 그러므로 이 장점은 모든 벤더가 일정한 수준까지 올라와야 목적을 달성한다고 할 수 있다. 그러나 필자는 지금 수준의 분산 환경에서 앞에서 언급한 장점처럼 소프트웨어의 이식성과 확장성을 달성한 것은 EJB뿐이라고 생각한다. 아마 자바의 매력을 그대로 이어받았기 때문이 아닐까.&#xD;
&#xD;
XML과의 뛰어난 연동 기능&#xD;
&#xD;
빈의 홈(home)과 리모트(remote) 인터페이스는 RMI(Remote Method Invocation)에 의해 운영됨에 따라, EJB의 CORBA와 연동성은 CORBA 객체와 RMI/IIOP(Internet INter-ORB Protocol)를 사용해 상호 작동할 수 있어 연동하는 데 불편이 없다. 따라서 썬은 이를 뒷받침하기 위해 EJB API와 CORBA IDL의 표준 매핑을 정의했다. JTA(Java Transaction API)는 빈이 관리하는 트랜잭션을 위해 OMG/OTS 트랜잭션 표준에 쉽게 겹칠 수 있게 했다.&#xD;
&#xD;
가장 강력한 다른 기술과의 연동성은 XML에 있다. EJB 1.0까지는 별로 XML과 관련성을 갖지 않았다가 버전 1.1부터 두 가지 측면에서 상호보완적으로 작동하기 시작했다. EJB는 이식성있는 모든 비즈니스 로직에 대해 표준을 정의하고, XML 기술은 이식성있는 데이터에 대해 표준을 정의한다. 다시 말해 EJB는 비즈니스 로직에 대한 분산 환경에서 컴포넌트의 정의, 이식, 컴포넌트에 전달할 경우에 데이터 관리는 XML 기술로 한다.&#xD;
&#xD;
EJB는 이를 사용할 수 있는 API를 제공해, 개발자가 쉽게 컴포넌트를 활용하도록 한다. EJB뿐만 아니라 모든 산업 분야에서 XML은 데이터를 교환하고 저장할 때 데이터베이스를 이용하지 않고 처리하기 위해 사용된다. 그러므로 EJB를 깊이 이해하려면 XML에 대한 이해가 필수적이다.&#xD;
&#xD;
EJB의 역사는 흐른다&#xD;
&#xD;
최 대리가 EJB를 활용하기 위해 고려해야 할 사항은 많았다. 특히 EJB의 구현 제품은 초기 상황이라 그런지 매우 다양하고, 이를 지원하는 스펙과 사용법은 약간씩 차이가 있었다. 이에 따라 개발에 EJB를 사용하려면 매우 꼼꼼한 검토가 필요했다. 각 버전의 차이로 인해 프로그래밍 방법이 조금 달라지는 경우는 매우 곤혹스러웠다. 추후 그런 점을 모두 관리했다가 버전이 올라가면 그에 대한 처리가 필요하다는 것을 의미했다. 게다가 각각의 차이점은 스펙에서부터 존재하기 때문에 구현 제품에서 차이점이 존재하지 않는 경우는 드물다. 각 스펙의 차이점은 대략 다음과 같다.&#xD;
&#xD;
EJB의 과거, 스펙 1.0&#xD;
&#xD;
최 대리가 스펙 1.0과 1.1 개발에서 가장 당혹했던 것은 기존에 관리하던 EJB 관련 배포 기술자(DD, Depl oyment Descriptor)가 전부 XML 파일로 바뀌면서 XML을 이해하지 않고는 배포할 수 없다는 점이다. 즉, EJB의 기술 뒤에는 XML 기술이 엄청나게 유입됐다는 것이며, XML이 정보 기술 세계에서 활용도가 높아지는 것을 피부로 느낀 것이다. EJB와 XML은 뗄래야 뗄 수 없는 관계가 됐다. 또 CORBA와 관련했던 IIOP 프로토콜이 RMI를 제치고 여러 시스템과 통신하기 위한 표준 프로토콜로 떠오른 점이었다. 다음은 주요한 차이를 보여준다.&#xD;
&#xD;
배포 기술자가 XML 포맷을 지원하므로 내용 구성이 한결 강화돼 쉽게 개발, 배포할 수 있다. &#xD;
EJB 배포할 때 설정한 환경 속성은 JNDI(JAVA Naming and Directory Interface)를 사용해 EJB 내부에서 접근할 수 있다. &#xD;
컴포넌트에 관련한 서로의 역할을 명확히 구분해 좀더 높은 이식성을 제공한다. &#xD;
새로운 리소스 팩토리(Resource factory)를 지원한다. java. sql.Datasource()이며 JDBC(JAVA DataBase Connectivi ty) 커넥션 풀에 접근할 수 있으며, URL 연결과 자바 메일 팩토리, JMS(JAVA Message Service) 연결 등을 제공한다. &#xD;
CMP(Container Managed Persistency)에서 ejbCreate의 필수 리턴 값이 프라이머리 키 클래스로 달라졌다. &#xD;
엔티티빈의 프라이머리 키 클래스는 해당 엔티티의 프라이머리 키가 1개일 경우 프라이머리 키 클래스를 선언하지 않아도 된다. 그러나 프라이머리 키가 기본적인 데이터 형태(int 등)일 경우는 프라이머리 키 클래스가 필요하다. 만약 프라이머리 키 클래스를 선언하지 않고 사용할 때는 프라이머리 키 필드를 반드시 배포 기술자에 기술해야 한다. 프라이머리 키 클래스는 hashCode(), equals() 메쏘드를 구현한다. &#xD;
빈의 메쏘드를 구현할 때 RemoteException은 던지지 않는다. &#xD;
엔티티빈의 finderXXX 메쏘드에서 FinderException을 꼭 th row해야 하고 java.util.Enumeration 이외에 java.util.Collec tion를 사용할 수 있다. &#xD;
javax.jts.UserTransaction가 javax.transaction.UserTransa ction으로 변경됐다. &#xD;
엔티티빈에서는 UserTransaction을 사용할 수 없다. &#xD;
UserTransaction과 SessionSynchronization을 동시 사용할 수 없다. &#xD;
파일 기반의 데이터 영속성은 지원하지 않는다. 만약 이런 엔티티빈을 갖고 있어 다시 사용하려면 CloudScape 데이터베이스를 사용하는 게 대안이 될 수 있다. 현재까지는 CloudScape는 누구나 쓸 수 있기 때문이다. &#xD;
컨테이너는 setRollbackOnly()를 호출한 빈의 트랜잭션만을 롤백한다. &#xD;
javax.ejb.EJBContext의 getCallerIdentity, isCallerInRole 메쏘드가 퇴출됐다. 왜냐하면 Java2에서는 java.security. Identity를 퇴출했기 때문이다. &#xD;
javax.ejb.EJBContext의 getEnvironment()가 퇴출됐다. 새로운 JNDI를 이용해 접근하도록 했기 때문이다.&#xD;
EJB 미래, 스펙 2.0&#xD;
&#xD;
EJB 2.0이 표방하는 것은 크게 두 가지이다. 첫째는 데이터베이스로부터 독립적이고, 강력하게 조작하기 위한 기반을 제공하며, 메시지를 이용한 비즈니스 로직 처리를 새로 도입한 점이다. CORBA와 관련했던 부분도 버전 1.1에서 보다 많이 확장한 것 같다. 가장 주요한 특징을 보면 빈의 새로운 형태인 메시지 드리븐 빈(MDB, Message driven bean)을 통해 JMS를 지원한다. MDB는 JMS 메시지가 도착하면 컨테이너를 호출한다. MDB는 클라이언트 입장에서 보면 서버의 어떤 비즈니스 로직을 수행한 JMS 소비자이다. 클라이언트는 MDB와 JMS 데스티네이션에게 메시지를 전송함으로써 통신한다. MDB는 세션빈(SessionBean)과 엔티티빈(Entity Bean)과는 명확히 다르다. 홈이나 리모트 인터페이스가 없는 대신 javax.jms.MessageListner 인터페이스를 수행한다. JMS 관련 기술이 어떻게든 자바 관련 분야에서 상당히 많이 사용될 것이다.&#xD;
&#xD;
그리고 엔티티빈의 CMP를 위해 향상된 지원을 한다. 영구적인 데이터에 대한 모델링 메커니즘을 새롭게 정의하고 엔티티빈을 위해 새로운 질의어를 정의한다. 영구적인 데이터 모델을 지원하는 부분은 새로운 추상 클래스를 엔티티빈과 관련 객체에 포함하도록 한다. 이런 클래스는 영구적인 데이터를 위해 복잡한 모델을 정의하는 게 필요할 수 있다. 또한 빈이 지원하는 추상 스키마 정의에 필요한 배포 기술자의 새로운 엘리먼트 정의가 필요하다. 데이터 모델의 정의가 빈 개발자에게 주어지고 컨테이너의 배포 도구는 배포할 때 정당한 helper 클래스를 자동적으로 생성한다. EJB QL (Query Language)이라는 질의어가 현재 데이터베이스에 사용된 것과 무관하게 엔티티빈의 데이터 모델을 관리할 수 있도록 한다. 이 질의어는 엔티티빈의 추상 스키마, 관련 객체, 데이터 모델에 대한 객체의 관계를 사용한다. 기존의 SQL과 문법이 비슷하다. EJB QL은 빈 제공자에게 클라이언트가 특정 엔티티 객체를 선택할 수 있도록 한 홈 인터페이스에서의 finder 메쏘드와 클라이언트에 직접적인 데이터를 노출하지 않고 관련 데이터에 내부적으로 접근할 수 있는 select 메쏘드 등 두 가지 형태의 질의 메쏘드를 작성한다. 구현한 제품을 아직 테스트해보지 않았지만, CMP가 하나의 테이블만 관리하고 finder 메쏘드 안에서 표준 질의어와는 다른 형태의 문법을 지원한 검색 방법을 사용하므로 발생하게 된 불편 때문에 추가된 것이라고 생각한다. 네트워크 상호 운용을 위해 OMG(Object Management Group)의 IIOP 프로토콜을 근간으로 한다. 분산 트랜잭션을 확장하고 SSL(Secured Socket Layer)을 이용한 보안, 네이밍 서비스 접근은 모두 OMG 표준을 근간으로 한다.&#xD;
&#xD;
EJB 스펙 현황&#xD;
&#xD;
현재 EJB 구현 제품에서 지원한 스펙은 버전 1.1이 최신이다. 스펙 2.0에 대한 베타 버전이 나왔지만 아직 정식 버전이 나온 제품은 없다. 또 1.1 스펙을 완벽하게 지원한 제품도 많지 않고, EJB 적용시 함께 고려해야 할 JSP 버전도 매우 중요시돼야 한다. 이는 스펙에 충실하게 지원하다 보면 벤더의 역량이 부족할 수 있으며, 변화 속도가 너무 빠르기 때문일 수도 있다. 세부 스펙 현황은 다음과 같다.&#xD;
&#xD;
스펙 1.0 : March 21, 1998 &#xD;
스펙 1.1 : December 17, 1999 &#xD;
스펙 2.0 : May 31, 2000(Draft 2)&#xD;
EJB의 목표&#xD;
&#xD;
EJB는 개발자들이 애플리케이션을 쉽게 개발할 수 있도록 설계됐다. EJB 아키텍처는 여러 업체의 도구를 이용해 실행 시간에 상호 연동할 수 있는 컴포넌트을 개발, 보급할 수 있도록 한 컨트랙트(Contracts)를 정의한다. 자바 언어를 이용해 분산객체지향 비즈니스 애플리케이션을 개발할 수 있는 표준 컴포넌트 아키텍처를 제시하고, EJB 아키텍처는 현존 서버 플랫폼과 호환할 수 있도록 지원한다. EJB는 자바 API를 사용하며 비 자바 애플리케이션들과 CORBA와도 호환할 수 있다. EJB 활용의 가장 큰 목표는 컴포넌트와 트랜잭션 측면에 있다. 즉, 컴포넌트하면 떠오르는 것이 재사용성과 함께 개발자가 신경을 가장 많이 써야 할 트랜잭션에 대한 처리를 신경을 거의 쓰지 않도록 근간을 제공하는 것이다.&#xD;
&#xD;
EJB 아키텍처&#xD;
&#xD;
앞에서 말했듯이 EJB는 분산 환경에서 서버 사이드 컴포넌트의 아키텍처를 정의한다. 이 아키텍처의 구성은 각각의 역할 분담, 지켜야 할 규칙(컨트랙트), EJB의 종류, 트랜잭션 처리, 보안, 예외상황 처리 등으로 구분할 수 있다. 이제 EJB 아키텍처의 각 부분을 구체적으로 접근해 보자.&#xD;
&#xD;
기본적인 EJB 애플리케이션 아키텍처의 흐름은 &lt;그림 1&gt;과 같다. 외부의 다양한 형태의 클라이언트가 애플리케이션 서버에 존재한 컨테이너에 접근하기 위해 RMI/IIOP 프로토콜을 사용하며, 컨테이너는 서버가 제공한 트랜잭션, 보안, 네이밍, 기타 서비스 등에 대해 신경쓰지 않는 것을 볼 수 있다. 이와 같은 이해를 바탕으로 각 부분을 접근하면 쉽게 이해할 수 있다.&#xD;
&#xD;
아키텍처 역할&#xD;
&#xD;
아키텍처의 역할은 크게 6가지로 나눠진다. 그 중에서 시스템 관리자는 EJB와 직접 관련이 없으므로 개발자가 알아야 할 5가지 부분에 대해 알아보자. 이전에 스펙 1.0에서도 각각의 역할을 규정했지만 실제로는 그것을 정의하는 경계가 약간 모호했다. 이 점을 썬에서 염두에 뒀는지 스펙 1.1에서는 그 역할을 명확하게 구분했다.&#xD;
&#xD;
빈 제공자(Bean Provider) : 빈을 개발하는 개발자를 말한다. &#xD;
애플리케이션 조합자(Application Assembler) : 빈 제공자가 작성한 각각의 빈을 조합해, 큰 애플리케이션 단위 모듈을 생성한다. 이런 과정에서 빈이 아닌 다른 클래스 라이브러리도 포함할 수 있다. 실질적으로 빈을 배치하기 전 단계에서 이뤄진다. 빈 제공자로부터 받은 배포 기술자에 애플리케이션 조합 정보를 추가한다. &#xD;
배치자(Deployer) : 빈을 특정 EJB 서버에 등록, 배치하는 사람을 말한다. 빈이 특정 환경과 서버에 적용하는 단계에서 필요한 모든 정보를 배포 기술자에 정의한다. 보안 관련 사항을 설정하거나 환경 속성에 대한 부분을 해당 시스템이나 업무에 맞도록 조정, 설정한다. 실질적으로 운영할 때는 해당 운영 환경에 맞도록 빈을 배치, 관리를 책임진다. &#xD;
EJB 서버 제공자(EJB Server Provider) : 웹로직(WebLogic), 웹스피어(Websphere), JRun과 같은 EJB를 지원한 애플리케이션 서버를 말한다. &#xD;
EJB 컨테이너 제공자(EJB Container Provider) : 일반적으로 EJB 서버 제공자가 EJB 컨테이너까지 제공한다.&#xD;
EJB 서버와 컨테이너에 대해 좀더 알아보면, EJB 서버는 다른 EJB 서버와의 분산 트랜잭션을 처리하기 위한 역할을 수행한다. 또한 트랜잭션이나 서비스를 위한 로우 레벨이나 시스템 레벨의 처리, EJB 컨테이너, 인터페이스를 담당한다. EJB 컨테이너는 빈의 모든 처리를 담당한다(빈의 생성, 소멸, 인스턴스 풀 관리, 빈간의 트랜잭션, 보안 등). 그리고 트랜잭션 처리를 컨테이너가 담당함으로 개발자는 복잡한 트랜잭션 처리를 위한 로직을 작성하지 않아도 된다. 트랜잭션 처리를 어떻게 할 것인가에 대한 정보를 소스에서 분리해 트랜잭션 정책이 바뀌어도 소스를 수정할 필요가 없도록 한다. 빈의 동시 사용자 호출로 인한 데이터 무결성을 보장하기 위해 개발자가 동기화 로직을 추가할 필요가 없도록 한다. 또한 동기화 처리시 발생할 수 있는 데드락(dead lock)을 미리 방지해 개발자는 이런 부분을 고려해 작성할 필요가 없다. 보안 측면에서 컨테이너는 빈에 대한 사용자 권한을 정의할 수 있으므로 빈을 사용하는 권한을 확인하고, 인증 절차를 개발자가 직접 작성할 필요가 없다. 마지막으로 EJB 서버와 인터페이스한다.&#xD;
&#xD;
컨트랙트&#xD;
&#xD;
EJB 아키텍처의 근간은 서버 사이드 컴포넌트이므로 EJB의 이점을 달성하기 위해 클라이언트와 컴포넌트, 서버, 컨테이너 등 각 맡은 부분에 대한 정확한 표준 준수가 필요하다. 즉, 서로가 상대방이 이렇게 해주리라 기대하면서 그에 대해 각자 역할에 맞게 스스로 처리한다.&#xD;
&#xD;
EJB 아키텍처에는 클라이언트(Client-view-contract)와 컴포넌트(Component-contract)에서 준수해야 할 내용이 반드시 존재한다. 이런 내용을 따르지 않는 컨테이너나 클라이언트는 있을 수 없다. 즉, EJB 아키텍처를 구현해 제품으로 제공한 벤더는 이 컨트랙트를 따라 구현했고 클라이언트도 마찬가지로 EJB 컨트랙트에 따라 사용하므로 어떤 제품과도 별다른 변경 없이 옮겨 다닐 수 있는 것이다. 그러므로 EJB를 이해하는 최초의 작업이고도 중요한 부분이다. 그런데 이런 컨트랙트가 버전 1.0에서 버전 1.1로 업그레이드되면서 꽤 많이 변경됐다. 즉 1.0 버전을 그대로 활용할 수 없다. 아쉽지만 각 버전 1.0에서 개발한 컴포넌트를 버전 1.1에서 활용하려면 수정해야 한다.&#xD;
&#xD;
클라이언트 컨트랙트&#xD;
&#xD;
클라이언트 컨트랙트를 살펴보도록 하자. 이는 클라이언트와 컨테이너의 계약이라고 볼 수 있다. 첫 번째로 홈 인터페이스다. 이 역할은 EJB 객체를 생성, 제거, 검색한다. javax.ejb.EJBHome 인터페이스를 꼭 상속받아야 한다. 클라이언트는 홈 인터페이스 객체를 JNDI API를 통해 찾아낸다. 두 번째로 리모트 인터페이스다. EJB 객체를 접근하기 위한 인터페이스이며 클라이언트에서 불러 올 메쏘드를 정의한다. javax.ejb.EJBObject를 상속받아야 한다. EJB 객체는 이 인터페이스를 통해서만 접근할 수 있다. 세 번째로 EJB 객체를 클라이언트가 구별할 수 있는 식별자를 제공해야 한다(엔티티빈의 경우). 네 번째로 클라이언트가 실행할 때에 동적으로 호출하기 위한 EJB 객체의 메타데이타 인터페이스를 얻을 수 있어야 한다(물론 컨테이너의 역할이다).&#xD;
&#xD;
컴포넌트 컨트랙트&#xD;
&#xD;
컴포넌트 컨트랙트는 EJB와 컨테이너간의 계약으로 다음과 같은 특징을 갖는다.&#xD;
&#xD;
EJB 클래스의 비즈니스 메쏘드를 구현하는 책임은 빈 제공자에게 있다. &#xD;
컨테이너가 호출하려는 메쏘드, 예를 들어 ejbCreate, ejbPostCreate, ejbRemove, ejbFind&lt;METHOD&gt; 등은 빈 제공자가 구현한다. &#xD;
빈 제공자가 홈과 리모트 인터페이스를 정의하면 컨테이너는 그 인터페이스에 대한 구현을 책임진다. &#xD;
빈 제공자는 세션빈을 작성할 때 javax.ejb.SessionBean을, 엔티티빈인 경우 javax.ejb.EntityBean을 상속받아 구현한다. &#xD;
컨테이너 제공자는 엔티티빈의 CMP인 경우 빈의 영속성을 구현해야 한다. &#xD;
컨테이너는 javax.ejb.SessionContext 인터페이스를 세션빈에 제공해야 하고, javax.ejb.EntityContext 인터페이스를 엔티티빈 객체에 제공해야 한다. 이 의미는 빈 제공자는 빈 안에서 특정 변수로 해당 인터페이스의 객체를 담을 수 있도록 한다는 것이다. 추후 개발 예제를 보면 쉽게 이해할 것이다. &#xD;
컨테이너는 빈의 환경을 내포한 JNDI API context를 빈 객체에 제공한다. 빈 환경을 읽어 처리할 경우 이에 대한 메쏘드 등을 개발자가 고민할 필요가 없다.&#xD;
그 외로 컨테이너는 트랜잭션, 보안, 예외상황 등을 관리한다. &lt;그림 2&gt;는 컨트랙트를 보여준 그림이다.&#xD;
&#xD;
ejb-jar 파일&#xD;
&#xD;
ejb-jar 파일은 EJB 도구로 빈이 선언 정보와 함께 묶일 때 사용하는 표준 포맷이다. 빈 제공자와 애플리케이션 조합자, 애플리케이션 조합자와 배치자 사이에 적용한 계약이다. 그 내용은 빈과 홈 인터페이스, 리모트 인터페이스의 클래스 파일과 XML 배치 서술자이다. 모든 빈은 꼭 jar 파일로 묶어 배포한다. 1.0 스펙에서는 ser 파일과 jar 파일을 동시에 사용할 수 있으나 1.1 스펙은 jar 파일에서만 배포할 수 있다.&#xD;
&#xD;
EJB 객체의 종류&#xD;
&#xD;
EJB 객체는 크게 세션 객체인 세션빈과 엔티티 객체인 엔티티빈으로 분류할 수 있다. 우리는 먼저, EJB 아키텍처의 흐름을 알아둘 필요가 있다. &lt;그림 3&gt;은 클라이언트로부터 EJB 서버와 컨테이너까지의 흐름을 나타낸다.&#xD;
&#xD;
&lt;그림 3&gt;에서 EJB 기반은 RMI라는 것이며 RMI 기술이 서버와 클라이언트간의 통신을 구성하고 있다는 것을 알 수 있다. 필자도 오류를 경험한 것인데, 이것을 보고 유의할 사항은 RMI로 전달한 객체는 복사된 것이라는 점이다. 즉, 개발자는 어떤 특정 값을 리턴받기 위해 리턴 값을 활용하기도 하지만 파라미터로 객체를 넘겨 객체의 특정 변수에 값을 담아 리턴하기도 한다. 그러나 EJB 환경에서는 이것이 불가능하다. 특히 메시지를 전달하고자 할 경우 객체에 담아 전달하려면 전혀 원하는 대로 이뤄지지 않는다.&#xD;
&#xD;
세션빈&#xD;
&#xD;
세션빈이라고 칭하는 EJB 컴포넌트는 클라이언트와 세션이 맺어진 경우만 객체가 생성되고 서비스한다. 주로 비즈니스 로직을 처리하며 빈의 생명주기는 클라이언트와 세션이 유지될 동안만 존재한다. 여기서 말한 세션이란 물리적인 세션이 아니라 논리적인 세션이다. 즉, 하나의 빈과 클라이언트가 매칭되는 동안을 말한다. 그러므로 EJB 서버가 다운되면 모든 세션빈은 사라진다. 기본적인 세션빈인 경우 하나의 세션빈 인스턴스는 동시에 하나의 클라이언트에 의해 호출된다. 세션빈은 스테이트리스(Stateless) 세셔빈과 스테이트풀(Stateful) 세션빈이 있다.&#xD;
&#xD;
스테이트리스 세션빈&#xD;
&#xD;
스테이트리스 세션빈으로 기본적인 세션빈의 특수한 경우로 보면 된다. 어느 클라이언트와 세션이 맺어진 상태 정보를 유지하지 않고, 세션이 끊어지면 클라이언트 관련 정보도 없어진다. 그리고 한 개의 인스턴스는 여러 명의 사용자가 호출할 수 있다. 특정 클라이언트와 세션의 유지는 특정 메쏘드 동안만 유지된다. 세션빈 객체를 보존하지 않기 때문에 좀더 빠르다.&#xD;
&#xD;
스테이트풀 세션빈&#xD;
&#xD;
스테이트풀 세션빈은 클라이언트의 상태 정보를 계속 유지하고 클라이언트가 세션빈 객체를 요구할 때마다 최초에 생성된 객체가 서비스한다. 그러므로 한 개의 인스턴스는 한 개의 클라이언트에 매칭된다. 즉, 각각의 클라이언트는 각각의 빈 인스턴스와 매칭된다. 이런 형태는 풀(Pool)로 구성돼 서비스된다. 클라이언트와 서버간의 상호 작용과 관련한 정보을 관리한다.&#xD;
&#xD;
&lt;그림 4&gt;는 두 가지의 세션빈을 잘 보여준다. 스테이트리스 세션빈은 인스턴스 한 개가 여러 클라이언트에 서비스하고 있으며, 스테이트풀은 일대일로 서비스하고 있다. &lt;그림 5&gt;는 클라이언트 관점에서의 세션 객체의 생명주기(LifeTime)이다. 세션빈 객체는 최초로 ejbCreate()를 통해 생성되고 컨테이너가 각각의 세션빈을 관리한다. 애플리케이션 조합자나 빈 제공자는 각각의 자원 할당과 소멸이 빈과 더불어 어떤 이벤트에서 발생하는 지를 염두에 두고 사용할 수 있다.&#xD;
&#xD;
생명주기&#xD;
&#xD;
생명주기를 모른 상황에서 개발한 EJB와 어느 정도의 이해하고 개발한 EJB와는 차이가 크다. 개발자(빈 제공자, 애플리케이션 조합자)라면 이 개념과 더불어 꼭 알아둬야 할 것이 하나 더 있다. 그것은 세션빈의 세부적인 생명주기다. &lt;그림 6&gt;과 &lt;그림 7&gt;에서 스테이트풀과 스테이트리스의 생명주기가 어떻게 다른지를 세부적으로 비교할 수 있다. 스테이트풀은 개념상 풀 시스템을 활용한다. 그게 빠른 것처럼 보이지만 스테이트리스도 독특한 풀을 사용한다. 두 그림에서 이탤릭체로 작성한 부분은 클라이언트가 호출한 부분이고, 그 외 부분은 컨테이너가 호출한 부분이다. 스테이트리스의 특징은 보시다시피 전체 시스템에서 하나의 메쏘드 풀을 사용하며 메쏘드 풀에서 사용자가 임의로 remove() 메쏘드를 호출해도 빈 객체는 풀에서 내려가지 않는다. 즉, 컨테이너가 풀을 관리하며 필요에 따라 객체를 제거한다는 것을 알 수 있다. 그러므로 이 풀 관련 설정 작업은 컨테이너 관련 배포 기술자에서 정의하도록 한다.&#xD;
&#xD;
필자는 웹 애플리케이션을 많이 개발하다 보니 스테이트리스 세션빈을 많이 사용한다. EJB는 인터넷 환경에서 분산 처리가 주된 목적으로, 세션 처리는 웹 서버가 담당하므로 이에 대한 세션 관리를 이용해 컴포넌트를 작성할 일은 드물기 때문이다. 또한 그 아키텍처를 살펴봤듯이 스테이트리스 세션빈이 성능면에서 조금 나은 경향이 있기도 하다.&#xD;
&#xD;
엔티티빈&#xD;
&#xD;
영구적인 기억 장소에 저장된 어떤 엔티티빈의 객체 지향적인 관점에서 어떤 엔티티를 표현한 컴포넌트이다. 즉, 물리적으로 영구적인 데이터(persistence data)의 객체 표현이다. 일반적으로 관계형 데이터베이스를 표현한다. 버전 1.0에서는 파일이 영구적인 저장소로 취급됐으나 버전 1.1에서 파일은 저장소로써 취급받지 않는다. 영구적이므로 생명주기는 클라이언트와 관계없이 해당 데이터와 같이한다. 엔티티 객체는 생성부터 파괴될 때까지 컨테이너 안에 유지된다. 컨테이너는 클라이언트에게 투명하게 보안, 동시성, 트랜잭션, 영속성, 기타 서비스 등을 엔티티 객체에 제공한다. 두 개 이상의 클라이언트가 같은 데이터를 표현한 엔티티빈을 사용할 수 있다. 빈 인스턴스는 물리적으로 저장돼 있는 데이터에 대한 복사본을 갖고 있다. 엔티티빈의 속성(멤버 변수)은 영구적인 데이터 값과 매칭된다. 빈 인스턴스의 상태 변화시(멤버 변수의 값 변경) 영구 데이터와 동기화한다. 엔티티빈도 세션빈처럼 두 가지 종류가 있다.&#xD;
&#xD;
CMP&#xD;
&#xD;
Container-managed 빈은 Container Managed Persistency (CMP)라고 한다. CMP는 빈이 가진 속성과 영구적인 저장소간의 동기화를 컨테이너가 직접 처리한다. 빈 개발자는 JDBC를 이용한 데이타베이스의 처리 로직과 같은 영구적인 저장소와의 인터페이스 로직을 작성하지 않는다. 컨터이너가 관리한 필드(container-managed-field)들은 빈 구현 클래스에 public으로 선언한 멤버 변수로 정의된다.&#xD;
&#xD;
BMP&#xD;
&#xD;
Bean-managed 빈은 Bean Managed Persistency (BMP)라고 한다. BMP는 빈이 갖는 속성과 영구적인 저장소간의 동기화 코드를 개발자가 직접 작성해야 한다. 빈 개발자는 JDBC를 이용한 데이터베이스의 처리 로직과 같은 영구적인 저장소와의 인터페이스 로직을 작성해야 한다. 빈 구현 클래스 내의 ejbStore(), ejbLoad() 등 메쏘드에서 영구적인 저장소의 처리 로직을 구현한다. &lt;그림 8&gt;은 각 빈의 차이를 보여준다.&#xD;
&#xD;
이제 앞에서도 약간 언급했던 엔티티빈에 대한 Client-View 컨트랙트를 상세하게 알아보자. 홈 인터페이스 클라이언트가 홈 인터페이스를 JNDI로 설정할 때는 다음과 같이 코드를 작성한다. 이 코드는 EJB를 구현한 제품끼리 각각의 제품과 무관하게 작동하기 위한 기준을 제시한다.&#xD;
&#xD;
Context ctx = new InitialContext();&#xD;
AccountHome ah =&#xD;
   (AccountHome)javax.rmi.PortableRemoteObject.&#xD;
   narrow(ctx.lookup(...), AccountHome.class );&#xD;
&#xD;
이와 같이 기준을 설정한 까닭은 IIOP 프로토콜을 사용해 컴포넌트를 찾아내기 위한 것이다. IIOP를 사용하면 EJB가 CORBA 등과 연계시 제약을 전혀 받지 않기 때문이다. 원래는 다음과 같다.&#xD;
&#xD;
Context ctx = new InitialContext();&#xD;
AccountHome ah = (AccountHome)ctx.lookup(...);&#xD;
&#xD;
이 코드는 자바에서만 통용하는 방식이다. 또한 이를 통해 EJB 구현 제품마다 홈 인터페이스를 획득하는 요령을 한 개의 기준으로 설정해 버렸다는 점이다. 홈 인터페이스는 또한 다음과 같은 일을 클라이언트가 할 수 있도록 한다. 새로운 엔티티 객체를 홈 안에 생성하기, 홈 안에 있는 엔티티 객체 찾기, 홈으로부터 엔티티 객체 제거하기, 엔티티빈의 메타데이터 얻기, 홈 인터페이스의 핸들 얻기 등이다. 그리고 javax.ejb.EJBHome 인터페이스로부터 상속받아야 하며, 리모트 인터페이스를 위한 표준 코딩 규칙을 다음과 같이 따라야 한다.&#xD;
&#xD;
1. create 메쏘드 : 여러 개의 create()를 가질 수 있다. RemoteException, CreateException을 꼭 던져야 하고, 추가로 애플리케이션 예외상황을 포함할 수 있다. 리턴 타입은 항상 리모트 인터페이스다.&#xD;
&#xD;
public interface EmpHome extends javx.ejb.EJBHome {&#xD;
   public Emp create(int empNo, String ename, String job, int deptNo)&#xD;
   throws RemoteException, CreateException;&#xD;
}&#xD;
&#xD;
2. finder 메쏘드 : 여러 개의 finder 메쏘드를 가질 수 있다. 이 메쏘드는 홈 안에 있는 엔티티 객체의 집합 속에서 특정한 엔티티 객체를 찾는 기능을 제공한다. 흔히 말하는 SQL의 Select를 구현한 메쏘드다. 프라이머리 키를 사용해 엔티티 객체를 찾는 경우는 이미 정의된 findByPrimaryKey(primaryKey)를 사용하도록 돼 있고, 빈 제공자는 이 메쏘드를 필수적으로 선언해야 한다. 빈 클래스에서 구현할 필요는 없다(컨테이너가 처리). RemoteException, FinderException을 꼭 날려야 하고 추가적으로 애플리케이션 예외상황을 포함할 수 있다.&#xD;
&#xD;
public interface EmpHome extends javx.ejb.EJBHome {&#xD;
.....................&#xD;
   public Emp findByPrimaryKey (EmpPk pk) throws RemoteException,&#xD;
       FinderException;&#xD;
}&#xD;
&#xD;
3. remove 메쏘드 : 이 메쏘드는 이미 EJBHome에 선언돼 있다. 이 메쏘드가 호출되면 세션빈과 달리 즉각적으로 홈에서 제거한다. 이렇게 제거된 엔티티 객체에 접근하려면 java.rmi.NoSuchObjectException이 발생한다.&#xD;
&#xD;
public interface EJBHome extends Remote {&#xD;
   .....................&#xD;
   public void remove( Handle h) throws RemoteException, RemoveException;&#xD;
   public void remove( Object primaryKey) throws RemoteException,&#xD;
       RemoveException;&#xD;
}&#xD;
&#xD;
생명주기&#xD;
&#xD;
클라이언트 시점에서 엔티티빈 객체의 생명주기는 다음 &lt;그림 9&gt;와 같다. 엔티티 객체는 생성하기 전에는 없다. 또한 식별자도 갖지 않고 생성된 후 식별자를 가진다. CMP는 풀 시스템 아래서 작동한다. 클라이언트는 존재하는 엔티티 객체의 리모트 인터페이스를 세 가지 방법으로 얻을 수 있다.&#xD;
&#xD;
메쏘드 호출시 파라미터로 레퍼런스를 받는 방법 &#xD;
엔티티빈의 홈 인터페이스에 정의한 finder 메쏘드를 사용해 엔티티 객체를 찾는 방법 &#xD;
엔티티 객체의 핸들로부터 레퍼런스를 얻는 방법 &#xD;
이렇게 얻은 리모트 인터페이스는 다음과 같다. &#xD;
엔티티 객체의 비즈니스 메쏘드 호출 &#xD;
홈 인터페이스의 레퍼런스 얻기 &#xD;
원격 메쏘드 호출의 파라미터나 리턴 값으로 레퍼런스를 넘기기 &#xD;
엔티티 객체의 프라이머리 키 얻기 &#xD;
엔티티 객체의 핸들 얻기 &#xD;
엔티티 객체의 제거(홈 인터페이스에서도 가능)&#xD;
프라이머리 키와 식별자&#xD;
&#xD;
각 엔티티 객체가 서로 동일한지를(즉, 같은 레코드인지) 판단하기 위한 방법을 EJB 아키텍처는 제시한다. 클라이언트는 현재 레퍼런스하고 있는 리모트 인터페이스의 getPrimaryKey() 메쏘드를 호출한다. 객체의 식별자(프라이머리 키 객체라고 봐야 함)는 리모트 인터페이스가 레퍼런스하고 있는 동안 즉, 존재하는 동안 절대 변하지 않는다. 그러므로 getPrimaryKey 메쏘드를 호출해 리턴받은 레퍼런스를 비교해 판단할 수 있다. 다른 방법으로는 isIdentical 메쏘드를 리모트 인터페이스에 사용하면 쉽게 비교할 수 있다. 주의할 점으로는 ‘==’나 equals 메쏘드를 사용하면 안된다는 것이다.&#xD;
&#xD;
리모트 인터페이스&#xD;
&#xD;
클라이언트가 엔티티 객체에 접근할 수 있는 인터페이스다. javax.ejb.EJBObject를 상속받아야 하고 엔티티빈에 구현된 비즈니스 메쏘드와 동일하게 메쏘드를 정의해야 한다. Javax.ejb.EJBHome은 다음에 소개한 일을 할 수 있도록 지원해 리모트 인터페이스가 비즈니스 메쏘드를 호출하는 것 외에 추가적으로 할 수 있도록 한다.&#xD;
&#xD;
엔티티 객체의 홈 인터페이스 얻기 &#xD;
엔티티 객체 제거 &#xD;
엔티티 객체의 핸들 얻기 &#xD;
엔티티 객체의 프라이머리 키 얻기&#xD;
엔티티빈 핸들&#xD;
&#xD;
엔티티 객체의 핸들은 네트워크에서 엔티티 객체를 구별하기 위한 객체다. 앞서 소개했듯이 리모트 인터페이스의 getHandle() 메쏘드를 사용하면 엔티티 객체의 핸들을 얻을 수 있다. 이렇게 얻어진 핸들을 다른 프로세스와 시스템에서 빈을 사용하기 위해 또는 추후 엔티티 객체의 레퍼런스를 다시 얻기 위해 serialize할 수 있다. 클라이언트는 핸들 객체의 getEJBObject() 메쏘드를 호출해 리턴된 결과 값을 리모트 인터페이스로 변환하기 위해 javax.rmi.PortableRemoteObject.na rrow()를 반드시 사용한다. 다른 벤더가 만든 컨테이너에서 생성한 핸들은 서로 호환되지 않는다.&#xD;
&#xD;
ObjectOutputStream stream = ....;&#xD;
Accout account = ....;//Account가 리모트 인터페이스...&#xD;
Handle handle = account.getHandle();&#xD;
Stream.writeObject(handle);&#xD;
.......추후&#xD;
ObjectInputStream stream = ...;&#xD;
Handle handle = (Handle)stream.readObject(handle);&#xD;
Account account = (Account) javax.rmi.PortableRemoteObject.narrow&#xD;
   (handle.getEJBObject(), Account.class);&#xD;
account.debit(100);&#xD;
&#xD;
벤더 호환성&#xD;
&#xD;
클라이언트 프로그램에서 홈과 리모트 인터페이스의 클라이언트 사이드의 표현을 모든 EJB 호환 컨테이너와 상호작용하려면 꼭 javax.rmi.PortableRemoteObject. narrow() 메쏘드를 사용해야 한다.&#xD;
&#xD;
엔티티빈의 컴포넌트 컨트랙트&#xD;
&#xD;
이제 엔티티빈에 대한 컴포넌트 컨트랙트에 대해 좀더 알아보자. BMP와 CMP의 가장 큰 차이는 CMP는 컨테이너 도구에 의해 배포할 때 데이터 처리 컴포넌트가 생성된 반면 BMP는 엔티티빈의 일부에 데이터 처리 부분을 갖고 있다는 것이다. &lt;그림 10&gt;은 엔티티 객체의 생명주기다.&#xD;
&#xD;
엔티티빈의 생명주기는 컨테이너가 자동으로 시작하며 엔티티빈은 컨테이너가 미리 설정한 풀에 따라 각 인스턴스를 올려놓고 클라이언트의 생성 요청을 기다린다. 한편 각 엔티티빈은 자신만의 풀을 갖고 있다. 인스턴스가 풀 안에 존재할 경우 특정한 엔티티빈 객체에 연관된 것은 아니고 모든 풀 안의 인스턴스는 동일하게 취급된다. 그러므로 어떤 인스턴스라도 컨테이너에 의해 ready 상태의 전이시에 엔티티 객체에 연결된다. 객체가 pooled 상태에서 컨테이너는 엔티티빈의 finder 메쏘드를 수행할 수 있도록 객체를 사용할 수 있다. finder 메쏘드를 실행하는 동안 ready 상태로 옮겨지지 않는다.&#xD;
&#xD;
pooled 상태에서 Ready 상태로 되는 경우는 두 가지 뿐이다. 먼저는 신규 객체를 생성한 경우이고 나머지는 ready 상태에서 클라이언트의 요구에 부응할 인스턴스가 없을 경우 발생한다. Ready 상태에서 객체는 특정한 엔티티 객체의 식별자와 연계돼 있다. 당연히 특정한 비즈니스 메쏘드를 호출한 결과로 인해 변경되는 객체 상태는 ejbStore와 ejbLoad를 컨테이너가 호출한다. 이는 데이터 소스의 엔티티 상태와 객체의 엔티티 상태를 맞추기 위한 일이다. 컨테이너가 빈 객체를 passivate하기 위해 먼저 ejbStore를 호출해 데이터 상태를 일치시키고 ejbPassivate를 호출한다. 이 메쏘드가 호출되면 엔티티빈의 객체와 식별자를 분리시킨다. 또한 ejbRemove가 호출되면 엔티티 객체가 제거된다. 풀에서 제거된 경우는 컨테이너가 unsetEntityContext를 호출함으로써 발생한다.&#xD;
&#xD;
엔티티빈의 컴포넌트를 작성할 때에 지켜야 할 규칙은 다음과 같다. 기본적으로 버전 1.0과 달라지지 않았으나 그래도 EJB 1.0에서 작성한 빈을 재사용하기 위해 바꿔야 할 부분은 꽤 많다.&#xD;
&#xD;
파라미터가 없는 public 생성자를 정의 &#xD;
public void setEntityContext(EntityContext ec) : 리소스 할당 &#xD;
public void unsetEntityContext() : 리소스 해제 &#xD;
public PrimaryKeyClass ejbCreate() : 이 부분은 버전 1.0에서는 void로 넘겼으나 버전 1.1부터는 프라이머리 키 클래스를 리턴한다. 여러 개의 ejbCreate 메쏘드를 선언할 수 있다. 이는 홈 인터페이스의 create 메쏘드와 동일하게 파라미터해야 한다. 만약 홈 인터페이스에 어떤 create 메쏘드라도 없으면 해당 엔티티빈에서 ejbCreate() 메쏘드가 없어도 된다. 이는 새로운 빈을 생성하지 않겠다는 의미한다. &#xD;
public void ejbPostCreate() : ejbCreate() 메쏘드와 쌍으로 존재한다. &#xD;
public void ejbActivate(), public void ejbPassivate() &#xD;
public void ejbRemove() &#xD;
public void ejbLoad() , public void ejbStore() &#xD;
public PrimaryKeyClass ejbFind&lt;METHOD&gt;(), public Collection(or Enumeration) ejbFind&lt;METHOD&gt;() 자바 1.1에서는 Collection이 지원되지 않으므로 Enumeration만 사용할 수 있고 1.2에서는 Collection이나 Enumeration을 동시에 사용할 수 있다. &#xD;
엔티티빈에서 EntityContext 인터페이스의 메쏘드를 사용하는 것은 각각의 경우마다 다르다. 이에 대한 메쏘드 사용을 주의해야 한다. 만약 빈 안에서 허용되지 않은 메쏘드를 호출할 때 java.lang.IllegalStateException이 발생한다.&#xD;
트랜잭션 지원&#xD;
&#xD;
EJB의 트랜잭션에 대한 이해는 매우 중요하다. EJB가 분산 트랜잭션을 지원함으로서 애플리케이션 개발자들이 여러 사이트와 데이터베이스에 대한 프로그래밍을 아주 쉽게 처리하도록 지원하기 때문이다. 더구나 이런 여러 사이트는 다른 벤더의 EJB 서버일 수도 있다. 또 빈 제공자나 클라이언트 애플리케이션 개발자가 분산 트랜잭션의 복잡성을 알 필요가 없다. 그리고 빈 내부에서 프로그래밍은 EJB 컨테이너가 설정된 트랜잭션 속성에 따라 처리하는 것이 어울리지 않을 때 기대한 결과를 가져올 수 없다.&#xD;
&#xD;
트랜잭션 관리를 클라이언트에서 할 수 있는데, 이 경우는 클라이언트가 javax.transaction.UserTransaction을 사용했을 때다. &lt;그림 11&gt;은 클라이언트와 컨테이너가 트랜잭션을 관리하는 내용이다. 클라이언트가 트랜잭션을 begin()으로 시작하고 commit()로 종료한다. 이 의미는 클라이언트가 트랜잭션을 모두 책임진다는 것이다. 이와는 반대로 컨테이너가 관리하는 트랜잭션은 &lt;그림 12&gt;에서 보듯이 클라이언트의 호출을 받은 빈 A에 대해 자동으로 begin()을 호출하도록 컨테이너가 처리하고, 빈 B에 대해 처리가 끝나면 빈 A에서 클라이언트에 리턴시 자동적으로 commit()를 컨테이너가 호출한다.&#xD;
&#xD;
트랜잭션 처리에서 중요하게 생각해야 할 다른 부분이 Isolation Level(고립레벨)이다. 트랜잭션을 동시에 여러 클라이언트가 수행할 경우 각각 서로 영향을 얼마나 받을 것인가를 결정하는 것이다. 빈이 관리하는 트랜잭션으로 생성된 세션빈은 원하는 고립레벨을 프로그래밍해 줘야 한다. java.sql.Connection.setTransaction Isolation()라는 메쏘드를 사용해 처리한다. 그러나 컨테이너가 관리한 트랜잭션으로 생성된 엔티티빈은 컨테이너가 생성한 데이터 처리 클래스에 의해 고립레벨을 관리한다. &lt;리스트 1&gt;은 빈을 관리하는 트랜잭션의 예제이고, &lt;리스트 2&gt;는 컨테이너 트랜잭션이다. &lt;리스트 1&gt;과 &lt;리스트 2&gt;에서 알 수 있듯이 Usertransaction() 객체를 사용하느냐, 아니냐에 따라 트랜잭션을 구분해 처리할 수 있다.&#xD;
&#xD;
그럼, 이렇게 빈 제공자가 개발한 빈을 어떻게 애플리케이션 조합자가 트랜잭션 속성을 설정하는지 알아보자. EJB가 정의한 트랜잭션 속성은 크게 NotSupported, Required, RequiresNew, Supports, Mandatory, Never 등 6가지이다. 이 속성들은 컨테이너가 트랜잭션을 관리하는 경우에만 유효하다. &lt;표 1&gt;을 보면 쉽게 이해할 것이다.&#xD;
&#xD;
보통 트랜잭션 속성은 배포 기술자에 설정된다 그러나 배포자는 설정에 대한 의미를 정확히 알아둬야 한다. 추후 성능 부분에서 언급하겠지만 어떤 속성이냐에 따라 성능이 높아지거나 낮아지기 때문이다.&#xD;
&#xD;
예외상황 처리&#xD;
&#xD;
예외상황은 애플리케이션 예외상황과 시스템 예외상황이 있다. 이 두 가지는 사용하는 방법이나 성격 등이 매우 다르므로 주의해야 한다. 먼저, 빈 제공자가 빈을 작성할 때 모든 메쏘드에는 그에 적절한 예외상황이 발생할 수 있다는 점을 예상하고 클라이언트에 내보낸다. 그러면 클라이언트는 항상 try∼catch를 활용해 빈에서 발생한 예외상황을 처리한다. 애플리케이션 예외상황이 발생했다고 해서 빈 객체가 자동으로 클라이언트의 트랜잭션을 롤백시키지 않는다. 그러므로 클라이언트는 애플리케이션 예외상황으로부터 트랜잭션을 롤백시킬 수 있는 기회를 제공해야 한다. 예외상황 처리는 정해지지 않은 예외상황에도 대비해, 안전하게 처리하는 것이 주된 목적이다.&#xD;
&#xD;
애플리케이션 예외상황&#xD;
&#xD;
빈 제공자는 애플리케이션 예외상황을 정의하고 클라이언트에 내보낼 수 있는데 시스템 레벨의 문제에 대해 처리하는 것이 아니라 비즈니스 로직의 예외상황을 클라이언트가 처리한다. 만약 트랜잭션을 롤백 처리하기 위해서는 예외상황을 보내기 전에 EJBContext.setRollbackOnly() 메쏘드를 사용해 표시해 줘야 한다. 애플리케이션 예외상황은 java.lang.RuntimeExcep tion, java.rmi.RemoteException을 상속받으면 안된다. 이는 이미 시스템 예외상황에 예약돼 있기 때문이다.&#xD;
&#xD;
시스템 예외상황&#xD;
&#xD;
시스템 예외상황은 다양한 시스템 레벨에서 발생한 예외상황과 오류를 말한다. 이 예외상황이 발생하면 빈 메쏘드에 관련된 트랜잭션은 자동으로 롤백된다. 빈 안의 다른 메쏘드는 호출되지 않는다. 즉, 빈에서 바로 클라이언트로 예외상황이 던져진다고 생각하면 된다. 다음은 EJB 1.0 스펙과 1.1의 차이점이다.&#xD;
&#xD;
EJB 1.0 스펙에서 비즈니스 메쏘드나 컨테이너의 콜백 메쏘드 등이 비 애플리케이션 예외상황을 처리하기 위해 java.rmi.RemoteException을 사용했으나 1.1에서는 javax.ejb.EJBException 혹은 java.ejb.Runtime Exception을 사용한다. &#xD;
1.1에서는 객체에 의해 던져진 모든 비 애플리케이션 예외상황은 트랜잭션을 롤백하고, 객체의 다른 메쏘드는 수행하지 않는다. 1.0에서는 롤백하지 않고 객체가 RemoteException을 던질 때만 객체의 다른 메쏘드를 수행하지 않았다. &#xD;
1.1에서 애플리케이션 예외상황은 컨테이너가 자동으로 롤백하도록 하지 않고 1.0에서는 컨테이너에 의해 시작된 트랜잭션에 대해 자동으로 롤백하도록 돼 있다. 그러나 1.1에서는 setRollbackOnly() 메쏘드를 호출할 경우에 객체는 롤백한다.&#xD;
분산 처리&#xD;
&#xD;
분산 환경에서 EJB는 RMI-IIOP 프로토콜을 사용하고, 클라이언트는 빈과 통신하기 위해 스텁을 사용한다. 그 스텁은 홈과 리모트 인터페이스를 구현한 것이다. EJB와 CORBA의 표준 매핑은 다음과 같이 상호 운용을 할 수 있다.&#xD;
&#xD;
어떤 벤더의 ORB를 사용한 클라이언트는 다른 벤더가 제공한 EJB 서버에 위치한 빈을 접근할 수 있다. &#xD;
한 개의 EJB 서버에 있는 빈은 다른 EJB 서버에 있는 빈에 접근할 수 있다. &#xD;
비 자바 플랫폼 CORBA 클라이언트는 어떤 빈 객체라도 접근할 수 있다.&#xD;
EJB 환경 처리&#xD;
&#xD;
EJB의 환경은 빈 배포나 조합시에 빈 소스에 접근해 변경할 필요 없이 빈의 비즈니스 로직을 커스터마이징할 수 있는 메커니즘이다. 컨테이너는 빈 환경을 구현하고 JNDI 인터페이스는 빈 개체의 빈 환경을 제공한다. 빈 제공자는 배포 기술자 수행시에 제공될 모든 환경 항목을 정의한다. 빈 객체는 자신의 빈 환경을 다른 빈과 공유할 수 없다. 또한 수행할 때 수정할 수 없고, 읽기만 할 수 있다. &lt;리스트 3&gt;은 새롭게 읽어오는 형태에 대한 예이다. 환경 항목을 선언하는 것은 배포 기술자 파일(ejb-jar.xml)에서 &lt;리스트 4&gt;와 같이 한다.&#xD;
&#xD;
EJB 1.1에서 EJB 레퍼런스라는 새로운 용어가 등장했다. 이는 빈 제공자가 다른 빈의 홈을 참조할 때 배포 기술자의 환경 항목에 정의해 사용한다. 이때 사용하는 방법은 앞에서 했던 것과 거의 동일하다. 그러나 환경 항목의 이름이 조금 다르다. &lt;리스트 5&gt;는 프로그래밍 인터페이스의 예로 환경 항목을 가져오는 것과 동일하다. 그러나 배포 기술자에 기술하는 것은 다르다는 것을 &lt;리스트 6&gt;에서 알 수 있다. 만약 한 개의 EJB 레퍼런스를 특정 빈에 연결하려면 ejb-link라는 엘리먼트를 사용한다(&lt;리스트 7&gt;). 그러면 빈 안에서 데이터베이스 등과 같은 시스템의 리소스를 활용하고자 할 경우는 &lt;리스트 8&gt;처럼 사용한다. 이에 대한 배포 기술자에서의 기술은 &lt;리스트 9&gt;와 같다.&#xD;
&#xD;
보안&#xD;
&#xD;
EJB는 빈이나 빈 안에 메쏘드별로 권한을 설정할 수 있다. 권한을 가진 클라이언트만이 빈을 사용하거나 메쏘드를 호출할 수 있다. 이러한 보안을 사용하도록 요구하는 경우는 드물기 때문에 직접 사용할 일은 없겠지만, 보안은 요즘 정보 기술에서 핫 이슈인 만큼 참고로 알아두면 유익할 것이다.&#xD;
&#xD;
역할&#xD;
&#xD;
해당 빈을 호출한 사용자의 역할(Role)을 정의하는 것이며 여러 부류가 있을 수 있다. 각각의 부류는 역할을 가지고 빈을 사용할 수 있도록 정의한다. 예로 부서 관리자(manager)는 모든 빈과 빈의 모든 메쏘드를 호출할 수 있지만 일반 사원(employee)은 특정 빈의 특정 메쏘드만을 호출하도록 역할을 구분할 수 있다. 각각의 EJB는 서로 다른 역할을 정의할 수 있으며 하나의 EJB 내에 각각의 메쏘드에 대해 서로 다른 역할을 정의할 수 있다. 이런 역할 정의는 개발자가 정의한다.&#xD;
&#xD;
Principal&#xD;
&#xD;
역할은 단지 논리적으로 사용자 부류를 구분하고, 정의한다. Prin cipal은 각각의 역할에 속한 실제 사용자나 그룹을 정의한다. 즉, 사용자별 권한을 매핑하는 것이다. 예로 매니저 역할에 해당하는 사용자 id는 yufirst이고, 일반 사원에 해당한 사용자는 guest 그룹을 가진 사용자라고 정의할 수 있다. Principal의 정의는 빈 배치자에 의해 설정된다.&#xD;
&#xD;
배포&#xD;
&#xD;
개발된 컴포넌트 EJB는 분산 환경에서 배포(Deployment)될 경우 배포 기술자에 기록된 정보에 근거해 배포한다. 즉, EJB를 사용하기 위해 EJB가 배포(쓸 수 있도록 분산 등록됨)돼야 하는데, 그 배포 처리를 기술한 것이 배포 기술자이다. 그러므로 배포 기술자는 빈 개발과 관련없는 사용에 필요한 정보를 담고 있다.&#xD;
&#xD;
배포 기술자는 단도직입적으로 ejb-jar 파일을 어떻게 정의하느냐에 좌우된다. ejb-jar 파일은 빈 제공자에 의해 작성될 경우 애플리케이션 조합 지침을 포함하지 않고, 애플리케이션 제공자에 의해 작성할 경우는 한 개 혹은 더 이상의 빈에 대한 애플리케이션 조합 정보까지 포함한다. 즉, 배포 기술자는 크게 두 부분으로 구성돼 있다.&#xD;
&#xD;
EJB의 구조 정보 &#xD;
애플리케이션 조합 정보&#xD;
스펙 1.0 버전에서 1.1 버전으로 넘어오면서 배포 기술자도 많이 변경됐다. 1.0에서는 TXT 파일을 이용해 기술했으나 1.1에서는 XML 파일을 이용해 기술하도록 전부 바꿨다. 그러나 이전 버전에서 개발한 EJB를 활용할 경우 배포에 필요한 정보가 TXT 파일에 있으므로 이를 XML 파일로 변환할 수 있는 도구를 각 EJB 서버 제공자가 지원한다. 한마디로 배포 기술자는 해당 빈에 대한 각종 속성을 정의한 파일이며 그 속성은 다음과 같다.&#xD;
&#xD;
트랜잭션 처리 &#xD;
보안 처리 &#xD;
환경 속성 &#xD;
리소스 사용 &#xD;
세션빈의 상태 관리 형태(스테이트리스, 스테이트풀) &#xD;
엔티티빈의 영구적인 형태(bean-managed, container-managed) &#xD;
컨테이너에 의해 관리된 필드를 정의 &#xD;
엔티티빈에서 필요한 finder 메쏘드, 프라이머리 키 정의&#xD;
빈 개발자, 애플리케이션 조합자(Application Assem bler), 배치자(Deployer)자가 모두 이 파일을 이용해 역할에 해당하는 내용을 정의한다. XML 형태이므로 EJB 1.1에 해당한 XML 문서의 DTD는 다음의 위치에서 정의한다.&#xD;
&#xD;
http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd&#xD;
&#xD;
EJB 작성 방법&#xD;
&#xD;
그러면 EJB를 적용해 빈을 어떻게 작성할 것인가. 이것은 대부분 쉽게 받아들이고 적용할 수 있으나 트랜잭션과 예외상황은 좀더 깊은 이해를 바탕으로 적용해야 한다. 트랜잭션을 어떻게 할 것인지에 대한 명확한 설정, 예외상황을 어떻게 처리할 것인지에 대한 적절한 대처 방안이 개발자에게 필요하다.&#xD;
&#xD;
빈 작성&#xD;
&#xD;
MVC 모델에 따라 세션빈은 단순한 비즈니스 로직을 적용해, 개발하고 데이터에 관련된 부분은 전부 세션빈이 아닌 엔티티빈에서 처리한다. &lt;리스트 10&gt;과 &lt;리스트 11&gt;은 세션빈에서 어떻게 엔티티빈을 처리하는지를 웹 프로그래밍을 할 경우 EJB 적용한 기본 템플릿이라고 보면 무리없을 것이다. ‘이달의 디스켓’을 참고하기 바란다.&#xD;
&#xD;
트랜잭션 처리&#xD;
&#xD;
트랜잭션을 어떻게 설정하느냐에 따라 빈 안에서의 트랜잭션 처리가 달라지므로 트랜잭션 속성을 이해하고 개발해야 한다. &lt;그림 13&gt;는 트랜잭션 속성에 대한 예이다. 보다시피 속성을 어떻게 정의하냐에 따라 서버의 EJB는 같은 트랜잭션으로 묶일 수 있는지 또는 없는지를 알 수 있다.&#xD;
&#xD;
&lt;그림 13&gt;의 경우 클라이언트 트랜잭션 객체를 T1이라 하면 세션빈 1을 호출할 때 Required로 한 경우 클라이언트의 트랜잭션이 세션빈 1에 그대로 유지된다. 엔티티빈 1과 엔티티빈 2가 모두 Requir ed로 돼 있기 때문에 트랜잭션 객체는 T1이다.&#xD;
&#xD;
세션빈 2인 경우 RequiresNew로 지정돼 세션빈의 트랜잭션과는 상관없이 새로운 트랜잭션 객체가 만들어지고(T2) 엔티티 3과 엔티티 4는 세션빈 2의 트랜잭션 객체를 그대로 유지한다. 따라서 세션빈 1 ,엔티티빈 1, 엔티티빈 2는 T1의 트랜잭션 객체를 세션빈 2, 엔티티 3, 엔티티 4인 경우 T2의 트랜잭션 객체를 갖고 있다. 따라서 T1은 T1끼리의 트랜잭션이 보장되고 T2는 T2끼리의 트랜잭션이 보장된다. 즉, 엔티티 4의 트랜잭션의 실패는 T1의 트랜잭션 객체를 갖고 있는 빈에 대한 롤백을 기대하면 안된다. 이와 같이 트랜잭션의 처리 속성은 경우마다 매우 다양하다. 필자가 가장 초기에 애를 먹었던 것은 트랜잭션을 User Transaction을 사용하지 않고 묶고 싶었는데 잘 안묶였던 것이다. 트랜잭션 속성을 잘 알지 못하고 사용했기 때문이다.&#xD;
&#xD;
예외상황 처리&#xD;
&#xD;
자바의 예외상황은 훌륭한 오류 처리 개념이다. 그러나 개발자가 개발하는 현실적인 현황을 보면 비합리적이다. 프로그래밍을 할 때 오류가 발생하지 않는 것을 최고로 생각하지만, 인간으로서 그렇게 하기는 어렵다. 오류가 발생했을 때 대처를 적절히 잘하는 것이 품질이 우수한 프로그램을 개발하는 조건이 될 수 있다. 이런 목적을 달성하기 위해 오류가 발생했을 때 이에 대한 대비를 가능한 최대화해야 한다. 그러나 대부분의 개발자는 오류 처리를 귀찮아해 아주 이상한 경우만 처리하도록 코드를 작성하기도 한다. 웹에서 분산 환경으로 프로그래밍의 방향이 바뀜에 따라 오류를 범할 가능성이 높아지고, 발생처 등을 파악하는 것이 복잡해지고 있는 추세다. 그러므로 예외상황에 대한 처리는 중요하고 필수적일 수 밖에 없다.&#xD;
&#xD;
빈 작성시 예외상황 처리는 매우 미묘한 차이를 가져와 개발자가 예상하지 못한 결과를 낳는다. 필자도 예외상황이 이 트랜잭션과 밀접한 관련이 있는지 모르고 트랜잭션만 중요하게 다루다가 예외상황과 트랜잭션과 깊은 연관성을 알고 각성했던 적이 있다. &lt;표 2&gt;, &lt;표 3&gt;은 예외상황을 처리하는 개념과 더불어 개발자가 처리해야 할 내용을 구분한 것이다.&#xD;
&#xD;
EJB 성능 향상 요령&#xD;
&#xD;
비용이 많이 드는 리소스를 얻을 경우, 얻은 것을 재사용하도록 한다. 이런 경우를 보다 자세히 알아보자.&#xD;
&#xD;
javax.sql.Datasource 재사용&#xD;
&#xD;
javax.sql.Datasource를 사용할 때마다 이런 자원을 얻을 경우와 한 번 얻어놓고 재사용하는 경우와는 최소 7배 이상의 차이가 난다. &lt;리스트 12&gt;와 같이 메쏘드를 만들어 놓고 재사용한다.&#xD;
&#xD;
빈이 관리하는 트랜잭션&#xD;
&#xD;
빈이 관리하는 트랜잭션에서는 javax. sql.Datasource로부터 얻은 커넥션은 항상 사용 후에 풀어줘야 한다(&lt;리스트 13&gt;). 점점 리소스가 줄어 들고 나중에는 더 이상 커넥션을 맺을 수 없다고 표시하고 다운되기도 한다. 만약 빈번하게 호출된 빈이라면 이런 것에 대해 철저하게 조심해야 한다. 이런 것은 개발자가 책임지는 영역이지만, 책임지지 못하는 영역도 있다. 예를 들면 JDBC의 버그로 인해 예외상황이 발생한 경우다. 데이터베이스에서 잘못된 데이터를 읽다가 JDBC가 예외상황을 발생시킨 경우는 개발자가 커넥션을 닫아도 리소스가 해제되지 않는 경우가 발생한다. 이런 경우는 정말 해결책이 없으므로 개발자만 고통받는 것은 없어져야 한다.&#xD;
&#xD;
EJB 홈을 재사용하기&#xD;
&#xD;
EJB 홈 인터페이스는 비싼 비용을 치러 얻은 자원이고, 재사용에 어떤 문제점도 발생히지 않으므로 홈 인터페이스를 한 번 사용한 경우 다시 재사용할 수 있도록 저장해 두면 유용하다. &lt;리스트 14&gt;의 소스를 보면 쉽게 이해할 것이다.&#xD;
&#xD;
이렇게 만들어진 메쏘드는 싱글턴(Singleton) 패턴을 이용해 메모리에 홈 인터페이스 풀 을 만드는데 사용될 수 있다. 위 메쏘드를 담은 객체가 HomeManager라는 싱글턴 클래스라고 할 경우 이용방법은 세션빈으로부터만 엔티티빈에 접근하기의 예에서 확인할 수 있다.&#xD;
&#xD;
세션빈으로부터 엔티티빈에 접근&#xD;
&#xD;
세션빈으로부터 엔티티빈에 접근에 대한 필요성은 두 가지 이유를 가진다. 하나는 리모트 메쏘드의 호출을 최대한 줄이자는 것이다. 클라이언트가 엔티티빈을 직접 접근할 경우 각각의 메쏘드 호출은 리모트 호출이다. 그러나 엔티티빈을 감싼 세션빈은 엔티티빈을 로컬로 접근할 수 있다. 그리고 스트럭처 형태로 데이터를 모아 값을 반환할 수 있다. 남은 하나는 엔티티빈에 외부 트랜잭션 컨텍스트를 제공하는 것이다. 엔티티빈은 각 트랜잭션의 완료시에 현재의 데이터베이스에 상태를 일치시킨다. 클라이언트가 엔티티빈을 직접 각자 호출할 때 각 메쏘드는 트랜잭션을 완료하게 한다. 그러면 ejbStore, ejbLoad 각각의 메쏘드에 따라 발생한다. 만약 엔티티빈을 둘러싼 세션빈이 트랜잭션 컨텍스트를 제공하면 엔티티빈은 세션빈이 트랜잭션을 완료할 경우에 그때서야 데이터베이스에 상태를 일치시킨다. &lt;리스트 15&gt;를 참고로 이해하자.&#xD;
&#xD;
표준 출력 사용하지 않기&#xD;
&#xD;
빈 안에서 표준 출력(Standard Output)을 사용하는 경우 디버깅하기 위해 특별히 사용하는 것 빼고는 절대 사용하지 말자. 메시지를 클라이언트에게 넘겨 처리 결과나 오류 상황을 처리하고 싶으면 빈 메쏘드의 리턴 타입을 Hashtable이나 Collection을 활용해 &lt;리스트 16&gt; 형태로 처리하게 한다. 여러 개의 객체를 리턴으로 넘길 경우도 이처럼 할 수 있다.&#xD;
&#xD;
Read-Only 메쏘드 설정하기&#xD;
&#xD;
엔티티빈에 대해 배포 기술자에서 설정할 때 클라이언트가 데이터베이스를 수정하지 않고 읽기만 하는 빈은 캐시전략을 Read-Only로 설정한다면 엔티티빈이 상태 일치 작업을 호출할 필요가 없다 따라서 엔티티빈을 배포시에 Read-Only 메쏘드로 설정하여 놀라운 성능향상을 꾀할 수 있다. 예들 들면 외부 에서 주기적으로 갱신하는 주식지표 같은 것은 클라이언트가 수정하지 않으므로 특정한 시간 간격으로 ejbLoad()만이 발생한다. &lt;리스트 17&gt;은 60초 마다 발생한다.&#xD;
&#xD;
고립 레벨 설정 유의&#xD;
&#xD;
트랜잭션 고립 레벨을 어떻게 설정하느냐에 따라 성능이 크게 차이난다. 대부분의 배포자는 트랜잭션 고립 레벨을 TRANS ACTION_SERIALIZE로 설정한다. 이 설정은 가장 오버헤드가 많이 초래되는 고립 레벨이다. 트랜잭션은 크게 5가지로 설정돼 있는데, 그 중 4가지가 트랜잭션과 관련있으므로 &lt;표 4&gt;를 참고로 사용하면 성능좋은 트랜잭션을 작성할 수 있을 것이다. 이런 설정은 java.sql.Connection.setTransactionIsolation(int)로 할 수 있다. 예전에는 배포 기술자가 했으나 1.1.부터는 API를 통하도록 돼 있다.&#xD;
&#xD;
EJB 제품 매트릭스&#xD;
&#xD;
EJB 아키텍처를 구현한 제품은 매우 많은 편이다. 약 40여 개 벤더가 제품을 제공하고 있는데, 각 제품이 지원한 표준 스펙의 버전이 다르다. 현재 빈 개발자는 ‘정말 빈이 호환되는가’ 라는 물음에 고개를 저을 수밖에 없다. 그러나 1.0이 지나고 1.1을 지원한 제품은 1.0보다 좀더 호환성이 강화되리라 기대된다. &lt;표 5&gt;에 나온 매트릭스는 주요 제품들에 대한 것이므로 EJB에 관련된 개발자라면 둘러보기 바란다.&#xD;
&#xD;
필자 연락처 : yufirst@dreamwiz.com&#xD;
정리 : 위윤희 iwish@sbmedia.co.kr&#xD;
&#xD;
&#xD;
--------------------------------------------------------------------------------&#xD;
&#xD;
소프트웨어 개발자 최 대리의 고민&#xD;
&#xD;
소프트웨어 개발업체에 종사하는 개발자 최 대리는 최근 폭발적으로 팽창한 B2B 시장에 내놓을 소프트웨어 패키지 개발을 담당하게 됐다. 패키지에 대한 기획 부분과 설계 부분은 다른 동료가 추진하기 때문에 최 대리는 실제 구현을 맡기로 분담했다. 최 대리의 고민은 시작됐다. 개발하려는 패키지는 다양한 조건을 만족해야 하는데 업무 설계 부분을 제외하더라도 패키지의 구현 부분에서 고려할 것이 너무 많았다. 따라서 최 대리는 프로그래밍의 실제 구현 부분에서 고려할 요소를 다음과 같이 몇 가지로 나눴다.&#xD;
&#xD;
패키지 운영 플랫폼은 어디서나 운용할 수 있도록 주요 플랫폼(OS, 서버 등)에 쉽게 이식되도록 한다. &#xD;
B2B 소프트웨어 특성상 여러 기업의 시스템에 연동하고 계약서와 송장 등의 문서를 주고 받아야 한다. &#xD;
세계시장을 대상으로 사업 영역을 개설함으로 인해 인터넷 환경에서 구동하는 애플리케이션이어야 한다. &#xD;
클라이언트가 어떤 데이터베이스를 사용할 지 알 수 없으므로, 데이터베이스에 독립적인 애플리케이션이어야 한다. &#xD;
데이터베이스의 데이터를 처리할 때 신뢰성이 최대한 보장돼야 한다.&#xD;
향후 개발된 패키지를 구입한 클라이언트가 플랫폼을 정하고, 그 플랫폼에서만 운영하도록 요구할 수 있으므로 주요 플랫폼에서 개발된 애플리케이션을 별도의 수정 없이 다른 플랫폼에 적용할 수 있게 자바로 작성했다. 다른 언어보다 성능은 약간 떨어지나 특정 플랫폼에 의존하지 않은 자바를 선택할 수밖에 없었던 것이다. 플랫폼에 독립적인 애플리케이션의 개발 언어로 자바를 선택하니 연동 부분이 문제였다. 그러나 이 연동 부분은 XML을 활용하면 매우 쉽다는 얘기를 듣고, XML/EDI 제품을 개발해 타사의 레거시 시스템과 연동을 처리하기로 했다. 즉, XML은 데이터의 구조를 쉽게 바꾸고, 데이터 검증도 간편하다. 그리고 웹 애플리케이션은 웹 서버, 운영 플랫폼과 밀접한 관계가 있으므로 고객이 선택한 웹 서버가 무엇이더라도, 그 웹 서버의 외부 서드파티 제품을 사용해 쉽게 이식하도록 고려했다.&#xD;
&#xD;
그러나 데이터베이스 부분은 매우 난감했다. 데이터베이스는 그 데이터베이스에 적합한 형태로 개발해야 하기 때문에 데이터베이스를 결정하기 전에 개발에 들어가기 어렵다. 그래서 데이터베이스에 의존적이지 않는 프로그래밍 방법을 조사했다. 컴포넌트 기반의 개발이 그에게 만족할만한 방향을 제시해줬다. 컴포넌트를 개발해 배포할 때에 어떤 데이터베이스에 배포할 것인지를 결정하므로 개발자는 데이터베이스에 대한 고민을 덜 수 있다. 또 웹 환경은 분산 환경에도 적절한 것 같았다. 그런데 컴포넌트를 개발하는 기술은 다양했다. 대표적으로 DCOM, CORBA, EJB 등이 있었다. 최 대리는 그 중에서 시장의 동향이 자바 관련 개발 기술이 비약적으로 발전하는 것을 근거로 EJB를 선택했다. EJB는 CORBA나 DCOM을 단순화하고 강화했기 때문에 향후 그런 부분이 필요하면 얼마든지 연계할 수 있다고 판단했다. 이렇게 결정하고 나니 최 대리는 EJB가 무엇인지 더욱 궁금해졌다.&#xD;
&#xD;
객체지향 설계란?&#xD;
&#xD;
객체 지향적인 설계는 OOD(Object Oriented Design)의 기본적인 사상인 MVC 모델을 근간으로 한다.&#xD;
&#xD;
M : Model&#xD;
&#xD;
데이터 엔티티를 표현하며, 데이터베이스 테이블의 엔티티에 대한 클래스 표현. 클라이언트 프로그램과 서버 프로그램간의 주고받는 파라미터로 쓰기도 한다. 데이터베이스의 데이터를 읽고 쓰는 기본적인 메쏘드를 가질 수 있다. EJB에서 대부분 엔티티빈이 담당한다.&#xD;
&#xD;
V : View&#xD;
&#xD;
UI(User Interface)에 해당되며, WEB에서는 HTML(JSP)이 담당하며, 자바 애플리케이션 환경에서는 스윙과 같은 컴포넌트가 담당한다. 사용자의 입/출력을 주로 담당한다.&#xD;
&#xD;
C : Control&#xD;
&#xD;
사용자의 View를 통한 입력과 Model 사이의 메시지 전달을 주로 담당하고, 비즈니스 로직을 처리하는 부분이다. 주로 세션빈이 담당한다.&#xD;
&#xD;
표준 애플리케이션 개발 스펙, J2EE&#xD;
&#xD;
EJB 구현 기술인 J2EE는 기업 전산 환경에서 자바를 이용한 표준화한 애플리케이션 개발 방법을 제공한 스펙으로, 다음과 같은 구성 요소를 가진다.&#xD;
&#xD;
데이터베이스 처리(JDBC, JTS, JTA) &#xD;
비동기 메시지 처리(JMS) &#xD;
분산 트랜잭션 컴포넌트(EJB) &#xD;
분산 객체(RMI) &#xD;
웹 애플리케이션(서블릿, JSP)&#xD;
개발자들을 위한 API 정의&#xD;
&#xD;
개발자을 위한 서버 프로그래밍의 개발 표준인 J2EE의 모든 스펙은 벤더에 의해 구현되며, 개발자는 표준 API를 이용해 개발한다. 윈도우, 유닉스, 리눅스 등 플랫폼에 영향받지 않는다. 개발자는 표준 API을 이용해 개발함으로써 플랫폼 변경시에도 포팅이 쉽다. 복잡한 트랜잭션 처리, 비동기 처리, 동시 사용자 처리 등에 대한 부담을 개발자로부터 덜어주고, 표준화한 분산 컴포넌트의 사용으로 확장성을 높인다.&#xD;
&#xD;
객체와 컴포넌트의 차이점&#xD;
&#xD;
컴포넌트는 객체지향 언어로 작성하지 않아도 된다. 하지만 일반적으로 객체지향 언어로 작성한다. 예로, 액티브X 컨트롤의 경우 C언어로 작성할 수 있다.&#xD;
&#xD;
그러나 객체는 반드시 OO(Object Oriented) 프로그래밍만 할 수 있다. 객체지향 언어로 작성한 한 개의 클래스가 객체 단위이다.&#xD;
&#xD;
한 개의 컴포넌트는 많은 객체를 가질 수 있다. 여러 객체들이 서로 연동해 동작하지만 컴포넌트를 사용하는 클라이언트 입장에서 이것은 하나의 컴포넌트다. 객체 개념은 컴포넌트 개념에 적용될 수 있다. 하나의 컴포넌트는 객체가 갖는 특성을 가진다(메쏘드, 속성, 캡슐화). 따라서, 한 개의 컴포넌트를 한 개의 객체로 볼 수도 있다. 객체는 일반적으로 소스 레벨에서의 재사용을 의미하고, 컴포넌트는 바이너리 레벨에서의 재사용을 의미한다. 소스 레벨에서 객체를 수정할 때 재컴파일이 필요하지만 바이너리 레벨에서 컴포넌트를 변경할 때는 재컴파일이 필요 없다.&#xD;
&#xD;
RMI 아키텍처&#xD;
&#xD;
EJB의 내부는 가장 근본적으로 리모트 메쏘드 이노베이션(Remote Method Invocation)이라는 RMI 아키텍처로 운영한다. 그러므로 RMI를 알고 있다면 EJB를 이해하는 데 유용한 기본 지식을 갖고 있는 것이다. 여기서는 간략하게 RMI에 대해 살펴본다.&#xD;
&#xD;
역할&#xD;
&#xD;
클라이언트가 자신이 원하는 일을 처리하기 위한 객체가 분산 환경의 어느 곳에 있던 호출해 메쏘드를 수행해 준다. RPC와 유사하다.&#xD;
&#xD;
작성 과정&#xD;
&#xD;
RMI는 구조상 두 개의 자바 클래스, 인터페이스와 인터페이스를 구현한 클래스를 필요로 한다. RMI를 작성하려면 먼저 인터페이스를 정의한다. 그 후 그 인터페이스에 대한 구현 클래스를 작성한다. RMI 컴파일러(rmic)를 통해 컴파일한다. 그러면 스텁(stub, 클라이언트에 다운로드한 클래스), 스켈레톤(skeleton, 서버에서 클라이언트 요청에 대해 처리하는 클래스)이 만들어진다. 즉, 스텁과 스켈레톤은 클라이언트와 RMI 구현 객체 사이에 중계 역할을 한다. 그 후 RMI 객체를 RMI 컨테이너에 등록해 클라이언트의 요청에 대해 수행할 수 있다.&#xD;
&#xD;
사용 과정&#xD;
&#xD;
클라이언트에서는 위에서 어떤 과정이 벌어지는지 알 필요 없이 인터페이스 클래스의 메쏘드를 호출한다. 다음 그림은 RMI의 사용 과정이다.&#xD;
&#xD;
트랜잭션 현상 보호의 용어 이해&#xD;
&#xD;
dirty reads : 트랜잭션이 다른 트랜잭션에 의해 아직 commit하지 않은 데이터를 읽음 &#xD;
non-repeatable reads : 트랜잭션이 이전에 읽은 데이터를 다시 읽은 후 commit된 다른 트랜잭션이 데이터를 수정하거나 삭제한 사실을 발견한 경우 &#xD;
phantom read : 트랜잭션이 검색 조건을 만족하는 행의 집합을 돌려주는 질의를 재실행한 후 commit한 트랜잭션이 조건을 만족한 행을 추가로 삽입한 사실을 발견한 경우&#xD;
&#xD;
&#xD;
유형열&#xD;
 &#xD;
</content>
    <postId>F4464D39-9C94-4FAD-BB04-F08A82A2E494</postId>
    <pubDate>2001-03-23T00:00:00-05:00</pubDate>
    <title>EJB 어제와 오늘  </title>
</post>
