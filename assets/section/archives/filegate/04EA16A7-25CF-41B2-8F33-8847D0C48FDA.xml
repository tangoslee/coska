<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>부기흡</author>
    <comments>
        <comment>
            <author>나수환</author>
            <date>2005-07-05T00:00:00-04:00</date>
            <content>참! 좋은 정보입니다.</content>
        </comment>
    </comments>
    <content>The development of an automated unit testing tool&lt;br&gt;&lt;br&gt;By: Sean McCormack&lt;br&gt;June 29, 2005 05:00 PM&lt;br&gt;&lt;br&gt;Automated unit testing has rapidly grown into an integral part of the development life cycle. With the increased usage of agile disciplines such as eXtreme Programming (XP) and Test Driven Development (TDD), along with the introduction of continuous integration tools such as CruiseControl.NET and Draco.NET, the need for automated testing tools has grown even stronger. If you've done unit testing in .NET, then chances are you've worked with NUnit, which was one of the first feature-rich testing applications available to the .NET Community. &lt;br&gt;&lt;br&gt; This article will outline the development of a similar testing tool called Zanebug. The need for Zanebug came about while developing a persistence framework for an eCommerce company. At the time, our team was using NUnit for all of our testing needs. Although it's an excellent framework, it unfortunately didn't provide all of the testing capabilities we needed - especially in the realm of performance-centric testing. As a result, I began to develop Zanebug as an open-source tool to address some of those needs, along with providing a more feature-rich UI. The current version of Zanebug provides a robust UI, a console version, and VS.NET integration. &lt;br&gt;&lt;br&gt;The development of Zanebug has been a fascinating experience. Although it's a free application, the challenges I encountered were similar to those of a commercial application. Additionally, because Zanebug has been used to test hundreds of real-world applications, it provides great insight into the challenges almost any development team may face, and how to solve them. &lt;br&gt;&lt;br&gt;The Joy of AppDomains&lt;br&gt;Dynamically Loading Assemblies&lt;br&gt;By far, the most challenging aspect of Zanebug was dealing with AppDomains. Anytime you launch a new application it runs in an AppDomain. When you dynamically load an assembly into memory, it is added to the list of assemblies in the current AppDomain. This unfortunately puts a lock on the loaded assembly, preventing it from being overwritten. For Zanebug to work effectively, it needs to load an assembly without locking so that a developer can make changes and recompile. If the assembly is locked by the AppDomain, the developer can't recompile his assembly without first closing the Zanebug GUI - which is far from ideal. In a perfect world, AppDomain would allow you to not only load an assembly into memory, but also unload it. Since this isn't the case with .NET 1.1, a different solution is required. &lt;br&gt;&lt;br&gt;The way to get around this is to create a remote AppDomain that copies the target assembly to a separate location and load it from there. This allows compilation to take place without any issues, while still being able to run tests. Unfortunately, AppDomain is a very picky class, and requires a lot of testing to get it just right. To help centralize the AppDomain functionality, an AppDomainManager class was created which allows you to load an assembly either locally or remotely with only a few API calls and hides the complexity of the AppDomain remoting. Another useful class that was created is AssemblyCache. Since loading assemblies into an AppDomain is an expensive operation, the AssemblyCache prevents this from happening more than once for any given assembly, and speeds the retrieval process. Both of these classes are available with the Zanebug source code. &lt;br&gt;&lt;br&gt;Assembly Probing&lt;br&gt;When you dynamically load an assembly, the CLR loads not only that assembly but also all of its dependencies. This can prove to be very problematic, since the CLR will only traverse the GAC and the immediate executable directory or subdirectories. If the CLR can't find what it's looking for, an exception is raised. This becomes an even bigger issue when dealing with a remote AppDomain that copies the assembly to a new location. Fortunately, there's a way to address this using the AppDomain.AssemblyResolve event. With AssemblyResolve, you can point the runtime to a different location outside of the common probing paths. In the case of Zanebug, the CLR probes the new temp path, and AssemblyResolve then probes the original assembly path. For your own purposes, you can point it to any location you want. &lt;br&gt;&lt;br&gt;Remoting&lt;br&gt;The fact that assemblies are dynamically loaded into a remote AppDomain brings a new slew of remoting issues to the table. The first main issue is that for the Zanebug GUI to interact with objects in the remote AppDomain, they have to either be marked as Serializable or inherit from MarshalByRefObject. The Serializable attribute allows an object to be sent back and forth as a value object. The MarshalByRefObject inheritance allows calls to be made to a remote object. An example of this is the TestRunner class, which actually executes the tests in the remote AppDomain. When a user clicks the "Run" button on the Zanebug GUI, it must tell the TestRunner to start running the tests. In order for this to work, TestRunner has to inherit from MarshalByRefObject so that the call to TestRunner can be made remotely from the Zanebug GUI. Likewise, the test results need to be sent back to the Zanebug GUI from the TestRunner. This is possible by marking the TestAssemblyResult as Serializable. &lt;br&gt;&lt;br&gt;A second issue is that console output within a Test wouldn't display in the Zanebug GUI, since it executes in the remote AppDomain. This required intercepting the console output and redirecting it to a StringWriter, which is then added to the test result and sent back over to the GUI via the serialized results object. The benefit of this approach is that all console output is stored within the test result, allowing you to save the console output and archive it for future viewing. &lt;br&gt;&lt;br&gt;A third issue was logging. Zanebug uses the excellent log4net library for all logging. Unfortunately, logging runs into the same issues with remoting. The log4net console output wouldn't be displayed and log files wouldn't be created because the primary AppDomain had a lock on it. The way this is resolved is to use the UDP appender and TraceTool to view the output. This allows for full logging to take place remotely and for the developer to view the results in real time. &lt;br&gt;&lt;br&gt;The last issue was with callbacks. Since Zanebug uses a progress bar to display how many tests have executed, it's necessary to send information to the Zanebug GUI each time a test completed, so that it can increment the progress. This is possible with event delegates. Event delegates are extremely powerful, allowing for multiple classes to "subscribe" to an event and be notified when that event occurs. Even better, event delegates work over remoting (as long as the information you send back is marked as Serializable). With delegates, I was able to create a number of events for the Zanebug GUI to subscribe to. &lt;br&gt;&lt;br&gt;Strong Naming and Versioning&lt;br&gt;Another interesting problem was whether to strong name the Zanebug assemblies. The Zanebug application, and all of its assemblies, is normally installed to C:\\Program Files\\Zanebug. When you load a test assembly from, say, D:\\projects\\Foo\\bin\\Debug, it will search for the Zanebug assemblies within Foo's Debug directory (as mentioned in the Assembly Probing section above). Therefore, it's necessary to somehow add the Zanebug assemblies to Foo's path. The two ways to do this are to either copy the Zanebug assemblies to the Foo directory or strong name the Zanebug assemblies and add them to the GAC. For various reasons, the copying approach wouldn't work for Zanebug, so the second approach was necessary. This introduced two problems however.&lt;br&gt;&lt;br&gt;&lt;br&gt;Installing to the GAC&lt;br&gt;If you use an installer other than the default VS.NET Setup project, you quickly run into an issue. The VS.NET installer provides the ability to add assemblies to the GAC. In the case of Zanebug, I use Inno - a free and very feature-rich installer. However, Inno has no concept of the GAC. You can't include a copy of the GacUtil with your project (due to Microsoft's licensing model), and you can't expect the GacUtil to be present on a user's computer, since they may have only installed the .NET runtime and not the SDK - so what do you do? The solution is to create your own GacUtil and call it during setup. This can be done using the System.EnterpriseServices.Internal.Publish class. &lt;br&gt;&lt;br&gt;Version Changes&lt;br&gt;Once you version an assembly and store it in the GAC, any application that is compiled against that version will automatically use it in the future. If, for example, Application A is compiled against Assembly 1.0, and you later add Assembly 1.1 to the GAC, Application A will still use Assembly 1.0. This is known as side-by-side versioning and provides a very flexible deployment model, since it allows you to deploy new versions of your application without affecting older ones. In the case of Zanebug, however, there's a need to always point applications to the most recent version of the framework in order to harness the latest capabilities. If developers compile their tests against Zanebug 1.4.4, and then install Zanebug 1.5.0, we want their tests to now use Zanebug 1.5.0. Likewise, Zanebug needs to point all NUnit tests to the latest 2.2 version, which is the version bundled with Zanebug. This is possible via bindingRedirect in the .config file. &lt;br&gt;&lt;br&gt;Attributes&lt;br&gt;Zanebug follows the lead of NUnit and uses attributes to mark all tests. Attributes are an excellent way to unobtrusively add run-time functionality. Through reflection, the Zanebug test engine is able to dynamically load an assembly and then look at each class and method to see if it has certain attributes associated with it. Even more important, Zanebug has full NUnit support that allows you to point to any existing NUnit test and run it within Zanebug. This is accomplished by looking for any Zanebug or NUnit attributes and then building the corresponding tests within the Zanebug test engine. &lt;br&gt;&lt;br&gt;The Road Ahead&lt;br&gt;Although Zanebug is in its infancy, it has quickly grown into a solid framework with rapidly growing use among the .NET community. In the most recent 1.5.0 release, VS.NET integration was added to the tool suite - a new area of challenging development. Moving forward, Zanebug will be providing an extensive array of new attributes to deal with common problems in testing, such as data access and list iterations. In the long term, Zanebug will provide a unified tool suite for unit, Web, and windows forms testing. At any time you can download the existing application and code base from www.adapdev.com/zanebug. &lt;br&gt;&lt;br&gt;Resources &lt;br&gt;&lt;br&gt;Zanebug homepage: www.adapdev.com/zanebug &lt;br&gt;TraceTool: http://tracetool.sourceforge.net/ &lt;br&gt;Log4net: http://logging.apache.org/log4net &lt;br&gt;NUnit homepage: http://nunit.sourceforge.net &lt;br&gt;&lt;br&gt;About Sean McCormack&lt;br&gt;&lt;br&gt;Sean is a C# MVP and serves as senior systems analyst for Miller Brewing Co., leading their .NET Architecture team. His previous experience includes serving as the director of technology for an eCommerce company and a touch-screen voting company, lead developer for an enterprise content management company, technical manager for a national automotive portal, and as an Arabic linguist and cryptologist for the Department of Defense. Sean currently leads the Adapdev open-source foundation, helping to develop top-notch open source applications for the .NET community. His two most recent applications include Zanebug (a unit testing tool) and Codus (a code generation tool).&lt;br&gt;&lt;br&gt;&amp;copy; 2005 SYS-CON Media Inc. &lt;br&gt;</content>
    <postId>04EA16A7-25CF-41B2-8F33-8847D0C48FDA</postId>
    <pubDate>2005-07-05T00:00:00-04:00</pubDate>
    <title>[test] Zanebug - Automated unit testing tool</title>
</post>
