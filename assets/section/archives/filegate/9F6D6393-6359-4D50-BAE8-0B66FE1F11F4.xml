<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>부기흡</author>
    <comments>
        <comment>
            <author>김형태</author>
            <date>2005-08-12T00:00:00-04:00</date>
            <content>어제 컨피그 팀 온라인 미팅 결과도 좀 올려 주시죠? ^^</content>
        </comment>
        <comment>
            <author>부기흡</author>
            <date>2005-08-12T00:00:00-04:00</date>
            <content>hi Andy, meeting minutes please :-)</content>
        </comment>
    </comments>
    <content>&lt;b&gt;Setting Up a Java Shop&lt;/b&gt;&lt;br&gt;&lt;br&gt;Configuration team members, please read and let's discuss - Ki&lt;br&gt;&lt;br&gt;==============================================&lt;br&gt;About Glen Cordrey&lt;br&gt;&lt;br&gt;Glen Cordrey is an architect and developer of J2ME and J2EE applications. He works in the Washington, D.C. area and has been working with Java for six years.&lt;br&gt;===============================================&lt;br&gt;&lt;br&gt;Three times in recent years I've joined an organization that was relatively new to Java development and missing some basic infrastructure elements that I'd relied on in previous development efforts. These elements include utility classes, standards and conventions, and build and quality control tools that help you produce a higher quality product with less risk. If you're involved in a development effort, whether it's new or ongoing, that's lacking any of these elements, you should consider incorporating them into your project infrastructure. &lt;br&gt;&lt;br&gt;&lt;b&gt;Nuts and Bolts&lt;/b&gt;&lt;br&gt;Some common utility software components should be incorporated into your development efforts as early as possible, because delaying their introduction may result in the proliferation of differing approaches that will need to be reworked later. &lt;br&gt;&lt;br&gt;&lt;b&gt;Configuration Settings&lt;/b&gt;&lt;br&gt;Access configuration settings via wrappers that hide the settings' underlying storage mechanism. There are numerous places where you can define configuration settings, including properties files, XML files, the database, and via the JDK's preferences package (which on Windows stores preferences to the registry, and to the file system on Unix). If your code uses direct calls to these mechanisms and future needs require that you either change which mechanisms are used or add functionality to those mechanisms, you'll need to make changes everywhere the mechanisms are referenced. &lt;br&gt;&lt;br&gt;For example, suppose developers store configuration settings in properties files and load and access the settings via calls to the Properties class sprinkled throughout their code. If sometime later you find that changes made to the configuration settings need to be reflected in the application while the application is running, you'll need to change the code that loads those properties to support reloading them. If the settings that need to be reloaded aren't all loaded by the same code - for example, some are UI settings loaded by UI code and others are network settings loaded by network code - you'll need to make the same types of changes in multiple places. &lt;br&gt;&lt;br&gt;You might also need to change the underlying storage mechanism. For example, a new customer might be database-centric and used to administering configuration settings in database tables and insist that your settings be administered the same way. If you're reusing a code base that has references to the Properties class throughout the code, you'll have to make a lot of changes to accommodate the new customer. &lt;br&gt;&lt;br&gt;You can roll your own configuration settings classes or harvest them from the Internet. If you can incorporate open source into your product, take a look at the Jakarta Commons Configuration package. If you need or prefer to roll your own, you could start with a simple factory+interface approach as in: &lt;br&gt;&lt;br&gt;public class ConfigFactory {&lt;br&gt;public static ConfigFactory getInstance() {...}&lt;br&gt;public Config getConfig( ) {...};&lt;br&gt;}&lt;br&gt;&lt;br&gt;public interface Config {&lt;br&gt;public int getInt( String settingName );&lt;br&gt;public long getLong( String settingName );&lt;br&gt;...&lt;br&gt;} &lt;br&gt;&lt;br&gt;You would then implement the Config interface once for each settings repository that you use, as in a ConfigProperties implementation, a ConfigXML implementation, etc. &lt;br&gt;&lt;br&gt;&lt;b&gt;Logging&lt;/b&gt;&lt;br&gt;If you don't have a logging package in place very early in your coding efforts, you can easily find yourself with a hodgepodge of logging approaches that make error investigation far more difficult than it should be. I've joined a number of large in-progress development efforts where almost every subsystem had its own custom logging package with numerous log files scattered in various directories, and log messages and message timestamps with varying formats. Consequently, one of the first hurdles in investigating a problem becomes determining, and locating, which log files may contain messages related to the problem. Then, if messages of interest are in multiple files, you may need to collate them into a chronological sequence, possibly reconciling different timestamp formats to do so. &lt;br&gt;&lt;br&gt;Your choice for logging should be between using the JDK logging APIs and Log4j, unless you have specific logging needs that can't be addressed by either package. The March 2005 issue of JDJ contained an excellent article, "Log4j vs java.util.logging," by Joe McNamara that can help you in your decision. &lt;br&gt;&lt;br&gt;If you're developing J2EE applications, an additional factor in your decision should be how easily your log messages can be directed to the application server's logging console and files. Many application server administration UIs have capabilities for displaying and filtering log messages, so if you can direct your messages to the application server's log message store, you can capitalize on those capabilities. In addition, having your log messages automatically collated with the application server's log messages may aid your problem investigation. For example, suppose your application fails because a resource pool in the application server was exhausted, but the error messages reported by your application contain insufficient detail to determine the cause. Having your messages in the application server log right after an application server message reports the exhaustion saves you considerable time in understanding the problem. &lt;br&gt;&lt;br&gt;If you need to support more than one logging mechanism, consider using the Jakarta Commons logging package, which provides a common logging API under which you can plug in JDK logging, Log4j, or a custom logger. However, realize that if you use this common API, you will be unable to access some features of the underlying implementation, as is explained at www.qos.ch/logging/thinkAgain.jsp by Ceki G&amp;uuml;lc&amp;uuml;, a key contributor to Log4j. &lt;br&gt;&lt;br&gt;&lt;b&gt;Exception Handling&lt;/b&gt;&lt;br&gt;Establish your exception handling approach early to ensure that you have mechanisms in place for the consistent and complete reporting and handling of errors. Decide on the project's philosophy regarding checked and unchecked exceptions - should checked exceptions be wrapped in unchecked exceptions? Your initial reaction might be "Why is this even an issue, since it defeats the point of having checked exceptions?" Well, a number of luminaries in the Java field, such as Bruce Eckel, advocate wrapping checked exceptions in unchecked exceptions (see www.mindview.net/Etc/Discussions/CheckedExceptions). One argument for doing so is that many developers don't really know what to do when a checked exception occurs. Because they're forced (by the compiler) to either catch it or declare it in their method's throws clause, they commit sins such as catching but not rethrowing it, which can make a problem investigation more difficult. (See Joshua Bloch's book Effective Java for a more extensive discussion on why consuming exceptions is bad practice.)&lt;br&gt;&lt;br&gt;&lt;br&gt;Regardless of which approach you subscribe to, consider incorporating default exception handlers into your architecture. The ThreadGroup class has an uncaughtException method that you can use to apply default processing for exceptions that propagate up from any threads in the ThreadGroup. With JDK 1.5, things get even better, as the Thread class has a setUncaughtExceptionHandler method that sets the handler for the thread, and a setDefaultUncaughtExceptionHandler method that sets the exception handler for all threads that don't have their own exception handler. &lt;br&gt;&lt;br&gt;&lt;b&gt;Shop Layout, Standards, and Procedures&lt;/b&gt;&lt;br&gt;Don't try to reinvent the wheel when it comes to deciding how to organize your project directories and defining development standards, guidelines, and conventions - there are plenty of resources on the Web to which you can refer. &lt;br&gt;&lt;br&gt;Sun has published directory and naming standards at http://java.sun.com/blueprints/code/projectconventions.html and http://java.sun.com/blueprints/code/namingconventions.html, which should be your preferred starting point unless other considerations are overriding. One such consideration might be your selection of a build tool - for example, Maven (discussed below) has a recommended directory structure. &lt;br&gt;&lt;br&gt;Sun also has published coding standards, although I find the Sun standards to be rather excessive and prefer fewer standards, with more focus on reducing potential sources of problems. In that light I recommend starting with the AmbySoft standards at www.ambysoft.com/javaCodingStandards.html, which also discuss alternative approaches for various items such as parameter naming. &lt;br&gt;&lt;br&gt;Ant is the de facto standard for building Java applications, but it isn't just for building, as it supports almost all development tasks short of writing code and project management. In addition, many product manufacturers such as application server vendors now provide Ant code for building with, configuring, deploying to, and/or managing their products. &lt;br&gt;&lt;br&gt;You can incorporate Ant into an automated build and test environment using CruiseControl. The advantages of doing so are explored in Martin Fowler's discussion of Continuous Integration (available from the CruiseControl Web page), and come from the observation that the earlier in the development process you find problems, the cheaper it is to fix them. Continuous Integration helps you find many problems soon after they are inserted into the baseline. &lt;br&gt;&lt;br&gt;You can also have CruiseControl automatically run various open source tools (discussed below) that identify potential bugs and quality issues in your code. These tools, along with Ant, can log their processing steps and results as XML, which means that their execution can be automatically analyzed and acted upon. For example, CruiseControl can analyze build results and send e-mail reporting on the success or failure of the build and automated tests. &lt;br&gt;&lt;br&gt;An alternative to the combination of Ant and CruiseControl is Maven, which provides a more comprehensive, project-management perspective. I haven't used Maven and so can't comment on it, but their Web site contains extensive documentation. &lt;br&gt;&lt;br&gt;&lt;b&gt;Quality Control and Improvement&lt;/b&gt;&lt;br&gt;You can improve the efficiency of your development effort and the quality of your product by incorporating automated tests using JUnit and tools built on top of it such as HttpUnit and Canoo WebTest. HttpUnit provides APIs that you can call to simulate requests from a browser, whereas with WebTest (which uses HttpUnit) you write XML to do the same. &lt;br&gt;&lt;br&gt;As mentioned earlier, a number of open source products exist to improve the quality of your code. FindBugs and PMD analyze your code to identify possible bugs, including sins such as the previously mentioned consumption of exceptions. JDepend helps you manage dependencies between Java packages, because it's easier to extend, reuse, and maintain packages if the dependencies between packages are well factored. JavaNCSS counts lines of code, number of classes, etc., and also computes cyclomatic complexity numbers (a.k.a. McCabe metrics), which can be used to identify code that is overly complex and should be considered for refactoring. &lt;br&gt;&lt;br&gt;Most (if not all) of these tools provide Ant targets and plugins for IDEs such as Eclipse. So in addition to running tools such as these as part of your build cycle, you should ensure that developers know about them and routinely run them against their code before checking it in. &lt;br&gt;&lt;br&gt;&lt;b&gt;Summary&lt;/b&gt;&lt;br&gt;These elements of a project infrastructure are low-hanging fruit - a modest investment of effort to incorporate them into your development efforts early on will provide benefits throughout development, helping you build better software faster.&lt;br&gt;&lt;br&gt;&lt;br&gt;&amp;copy; 2005 SYS-CON Media Inc. &lt;br&gt;</content>
    <postId>9F6D6393-6359-4D50-BAE8-0B66FE1F11F4</postId>
    <pubDate>2005-08-12T00:00:00-04:00</pubDate>
    <title>[config] technical article</title>
</post>
