<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>부기흡</author>
    <comments/>
    <content>Building an aspect-oriented framework based on annotations&lt;br&gt;&lt;br&gt;By: Peter Braswell&lt;br&gt;June 26, 2005 01:30 PM&lt;br&gt;&lt;br&gt;I'm really jazzed about Java 5.0! We've been treated over the years to incremental improvements in JVM performance. JDK 1.2 brought us the collections framework as well as Swing, the thread context class loader, and improvements in RMI. JDK 1.3 and 1.4 continued in the same vain with logical improvements to libraries, JVM enhancements, and performance upgrades. Although this article doesn't intend to take trip down memory lane, it's important to understand that Java 5.0 brings a truly remarkable and rich set of new tools to our programming landscape as compared to other JDK releases. &lt;br&gt;&lt;br&gt; This article will survey some of Java 5.0's new features and put them into practice through example. We'll build up a lightweight aspect-oriented system based on annotations to showcase what's new in 5.0. Some of these features you may be familiar with, some you may not. I've attempted to mix the obvious with some of the obscure. We'll examine some of the new hooks that the JVM has exposed for class loading, which makes the once dreadful work of bytecode manipulation during class loading much easier. In the "obvious" column, we'll look at generics and how they enable us to write more robust and sane programs, especially when dealing with collections. Perhaps the most notable aspect of Java 5.0 that we'll examine is the annotation framework. Annotations allow developers to inject metadata into their applications. We'll use this feature to demark classes we want manipulated at load time. To put this all in context, we'll create a lightweight framework that will manipulate classes as they are being loaded to enable logging, security, BAM (business activity monitoring), or any number of other scenarios that have yet to be dreamed up (The source code for this article can be downloaded from http://jdj.sys-con.com.) &lt;br&gt;&lt;br&gt;Annotations&lt;br&gt;Annotations are nothing new. In concept we've been injecting forms of metadata into our programs for years. If you've ever used XDoclet or EJBGEN to annotate a class in preparation for EJB deployment descriptor generation, you've used a form of annotation. Although these annotation methods are primarily manipulated during compilation, frameworks do exist that allow runtime access to annotations. Those that come to mind are the Jakarta Commons Attributes project and the metadata infrastructure in the Spring framework. One important thing to note from the Spring documentation regarding the use of Java 1.5 annotations versus metadata available in the Spring framework is the following: &lt;br&gt;&lt;br&gt;"JSR-175 metadata is static. It is associated with a class at compile time, and cannot be changed in a deployed environment. There is a need for hierarchical metadata, providing the ability to override certain attribute values in deployment - for example, in an XML file." &lt;br&gt;&lt;br&gt;For our purposes, however, the annotations suggested by JSR-175 and implemented in Java 5.0 will be sufficient. &lt;br&gt;&lt;br&gt;Anatomy of an Annotation&lt;br&gt;Generally, annotations are thought of only as artifacts useful at compile time by tool vendors to do such things as generating deployment descriptors. This is what utilities such as XDoclet and EJBGEN do. The annotations are examined at compile time, used to generate output (in the case of EJB this maybe a deployment descriptor) and in a sense are then discarded thereafter as an artifact. Annotations in Java 1.5 can behave in a similar way, but they can also be retained past the compilation stage and accessed at runtime. The developer has three retention policies to choose from. They are: &lt;br&gt;&lt;br&gt;RententionPolicy.CLASS: Annotations are to be recorded in the class file by the compiler but need not be retained by the VM at runtime &lt;br&gt;RententionPolicy.RUNTIME: Annotations are to be recorded in the class file by the compiler and retained by the VM at runtime, so they can be read reflectively. &lt;br&gt;RententionPolicy.SOURCE: Annotations are to be discarded by the compiler. &lt;br&gt;To declare a new annotation type, the developer must specify a retention policy for his or her annotation, what the element type is and what attributes the annotation possesses. The developer can associate an annotation with a particular element Valid element types are: &lt;br&gt;ElementType.Constructor: Associates an annotation with a constructor. &lt;br&gt;ElementType.Field: Associates an annotation with a field. &lt;br&gt;ElementType.LocalVariable: Associates an annotation with a local variable. &lt;br&gt;ElementType.Method: Associates an annotation with a method. &lt;br&gt;ElementType.Package: Associates an annotation with a package. &lt;br&gt;ElementType.Parameter: Associates an annotation with a parameter. &lt;br&gt;ElementType.Type: Associates an annotation with a type. &lt;br&gt;Let's look at a typical annotation declaration. &lt;br&gt;package annotations;@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.METHOD})public @interface BAMAnnotation{&amp;nbsp;&amp;nbsp;String insertionPoint();&amp;nbsp;&amp;nbsp;String processBean();}&lt;br&gt;What's notable here is that the annotation declaration is strikingly similar to an interface declaration and that the metadata for this annotation is defined in terms of an annotation! This particular annotation is used on a method and its values are accessible at runtime as dictated by the retention policy. The annotations require two attributes to be defined, "insertionPoint" and "processBean. To use this annotation in a class is pretty straightforward: &lt;br&gt;&lt;br&gt;import annotations.*;public class BizComponent{&amp;nbsp;&amp;nbsp;@BAMAnnotation(processBean="nullInjector",&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; insertionPoint="pre")&amp;nbsp;&amp;nbsp;public void execute()&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Executing"+&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "some biz functionality");&amp;nbsp;&amp;nbsp;}}&lt;br&gt;Here we've associated our annotation with the "execute()" method of our "BizComponent" class. When we examine this class at runtime the values of "processBean" and "insertionPoint" will be "nullInjector and "pre" respectively.&lt;br&gt;&lt;br&gt;&lt;br&gt;For those of you who have figured it out already or perhaps those of you who are wondering, what we are developing is a scheme by which we declare our aspect point-cuts via annotations. From a programming perspective we're dealing with an ordinary class (BizComponent) and we're using an annotation to tag it for bytecode engineering during the class-loading phase (more on this later). The nice thing about this approach is that the annotation (metadata) lives close to the source code eliminating the need to alter multiple source files. Compare this to "conventional" aspect-oriented programming where you have to declare this point-cut in a separate file and precompile or wire things up in an XML file like you would using Spring. &lt;br&gt;&lt;br&gt;Getting Annotation Information at Runtime&lt;br&gt;From a programming perspective, getting information out of an annotation is pretty straightforward. Continuing with the example that we've developed to this point, imagine that we have a candidate class that we want to examine for annotations. We know that only our methods are annotated, so given a class, we first extract all the "Method" objects and iterate over them searching for our annotations, like so: &lt;br&gt;&lt;br&gt;for( Method m : methods ){&amp;nbsp;&amp;nbsp;...&amp;nbsp;&amp;nbsp;Annotation [] annotations =&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m.getDeclaredAnnotations();&amp;nbsp;&amp;nbsp;for( Annotation a : annotations )&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("annotation type: "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+a.annotationType());&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(AMAnnotation.class.getName().&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; equals(a.annotationType().getName())&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Byte-code engineering here...&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;}}&lt;br&gt;Note the use of the new for loop iterator. Gone are the days where you have to iterate over unsafe, un-typed collections. Happy Days indeed! &lt;br&gt;&lt;br&gt;Once we have the Annotation object, getting properties is just as simple as this snippet of code demonstrates: &lt;br&gt;&lt;br&gt;if( getAnnotationProperty("insertionPoint", a.toString()).equals("pre")){&amp;nbsp;&amp;nbsp;...}&lt;br&gt;This code block simply pulls a property value out of the annotation and checks to see if it literally equals the string "pre." &lt;br&gt;&lt;br&gt;Great, What Happens Next? - Class Loading in 5.0&lt;br&gt;So now that we have our classes all annotated up, what do we do? Recall the intent of our Java 5.0 featured framework. We want to be able to annotate our classes (mark them) so that at runtime they are loaded in, examined, and altered (if they have the correct annotations) in such a way that a piece of code will run either before ("pre") or after ("post") our business method gets executed. &lt;br&gt;&lt;br&gt;The class-loading mechanism in Java 5.0 has been extended and has provided us with a really slick feature: agents! Very simply, an agent class is something that you pass along to the VM via a command-line argument that lets you do things PRIOR to your main being called. Among other things, you can install a class-file transformer that's invoked after the class has physically loaded into the VM, but before the class is handed back to the application. What this gives you is the ability to manipulate the class physically as it's being loaded by the JVM. Before Java 5.0, this involved somewhat tricky, awkward custom class-loader wizardry. No more! &lt;br&gt;&lt;br&gt;Here's the full implementation for our Agent class: &lt;br&gt;&lt;br&gt;import java.lang.instrument.*;public class Agent{&amp;nbsp;&amp;nbsp;public static void premain (String fqnBCEngineeringClass,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Instrumentation instrumentation)&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Install the new bytecode engineering loader&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ClassFileTransformer xformer =&amp;nbsp;&amp;nbsp;(ClassFileTransformer)Thread.currentThread().getContextClassLoader().getClass().forName(fqnBCEngineeringClass).newInstance();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instrumentation.addTransformer(xformer);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;catch(Exception ex)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ System.err.println("Could not instantiate Bytecode Engineering Class:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"+ex.getMessage()); }&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}} // class Agent&lt;br&gt;There's nothing special about an Agent class, other than it must contain the one static "premain(String, Instrumentation)" method. Besides that, it doesn't have to implement any particular interface or extend any particular class. So in our case our agent code will get called in advance of our static main being executed. This requires some special arguments to the JVM that we'll cover in a moment. When our premain gets executed, we'll have two parameters passed in. One is the fully qualified name of our bytecode engineering class and the other is the hook that we'll need to install it. &lt;br&gt;&lt;br&gt;Notice that the premain method dynamically (via reflection) tries to instantiate the transformer class and then turns around and installs it as a class-file transformer. The class instantiated here is the class that implements the interface "java.lang.instrumentation.ClassFileTransformer." In our case, this is the class that will do all the heavy lifting of the class file transformation. It's also the routine that slogs through classes looking for the marker annotations that slate a class for bytecode engineering. &lt;br&gt;&lt;br&gt;Getting the Agent class to execute requires a bit of legwork. First at compile time, we must create a Manifest file that specifies a premain class. The easiest way I've found to accomplish this is in the Ant script that assembles the jar. Here's a snippet of the Ant task that simply stipulates the correct name-value that gets injected into the Manifest file and will cause the JVM to call my agent class prior to calling main(). &lt;br&gt;&lt;br&gt;&amp;lt;jar jarfile="${dist}/j105.jar" update="true" &amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;fileset dir="${classes}"/&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;fileset dir="${configure}"/&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;manifest&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;attribute name="Premain-Class" value="Agent"/&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;/manifest&amp;gt;&amp;lt;/jar&amp;gt;&lt;br&gt;&lt;br&gt;Ok, we're almost done with the Agent installation. The only thing left is to pass the correct information into the JVM that causes the Agent to get called and the class-file transformer to be instantiated and installed. Here's the command line argument that accomplishes this: &lt;br&gt;&lt;br&gt;java -cp %CP% -javaagent:%DIST%\\j105.jar=MyTransformer Main &lt;br&gt;&lt;br&gt;It may not be clear as to what is happening here. The "-javaagent: [path to jar]\\[jar file]=[String Arg to Agent]" works like this: The jar file that's specified is the jar file that contains YOUR agent (in our case our "Agent" class). Recall that this jar file MUST contain the manifest file that specifies the premain class that is to be called. It was my experience developing this framework that simple mistakes in this setup cause nothing to happen! That is, your agent won't be loaded, your classes won't be transformed and your pre- or post-invocation methods won't be called with your business methods. The source code included with this article contains simple println statements that should tell you what is (or isn't) going on with the framework. &lt;br&gt;&lt;br&gt;Byte-Code Engineering&lt;br&gt;Up to this point I haven't introduced anything that isn't JDK straight out of the box, but unfortunately that won't get us where we want to go. So just to recap, we've developed the ability to mark classes that we're interested in transforming (injecting pre- or post-logic). We've created an infrastructure to install a class transformer that will re-engineer our classes at load time based on runtime annotations. Up to this point we've been dealing with stock JDK components, but it's time to take a little diversion. &lt;br&gt;&lt;br&gt;Recall earlier that we had to install a class that implemented the Java interface "java.lang.instrumentation.ClassFileTransformer." In the case of our little framework, the name of the class that does this is called "MyTransformer." We've already seen pieces of this class in this article. Recall the snippet of code that iterated over a collection of Methods in a class looking for our marker (the BAM annotation). What was omitted in that snippet was the actual mechanics of the class transformation. For stylistic reasons, I'm not going to include the entire class listing (please see the source code available with this article). So for a moment, imagine that we've intercepted a class being loaded, we've determined that it is annotated with our BAM metadata and that we now wish to introduce code that's either executed before or after the method we've determined contains our annotation. &lt;br&gt;&lt;br&gt;So as per the "ClassFileTransformer" interface, we must implement the following method: &lt;br&gt;&lt;br&gt;public byte[] transform (ClassLoader cl,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; String className,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Class&amp;lt;?&amp;gt; classBeingRedefined,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ProtectionDomain protectionDomain,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; byte[] classfileBuffer){}&lt;br&gt;In pseudo-code, what this method must do (in our framework) is to extract the Methods from the "classBeing-Redefined" parameter, iterate over them looking for annotations. We've already seen how this works. When we find a class that needs to be redefined (annotated), we must inject the pre- or post-code as directed by the annotation itself. To accomplish this injection, I used the "JavaAssist" toolkit for bytecode engineering. I've found this one of the easiest and most straightforward BCELs (Bytecode Engineering Libraries) to use. The code to do this looks something like this: &lt;br&gt;&lt;br&gt;CtMethod ctM = cc.getDeclaredMethod(m.getName()); if( getAnnotationProperty("insertionPoint", a.toString()).equals("pre") ) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;StringBuffer injectedCode = new StringBuffer();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;injectedCode.append("{");&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;injectedCode.append("System.out.println("initialize Spring...");\\n");&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;injectedCode.append("&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MyTransformer.getInjector(""+getAnnotationProperty("processBean",a.toString()&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; )+"").executeChain(null);\\n");&amp;nbsp;&amp;nbsp;injectedCode.append("}\\n");&amp;nbsp;&amp;nbsp;ctM.insertBefore(injectedCode.toString());}&lt;br&gt;JavaAssist makes re-engineering class files trivial. Notice that I simply concatenate together regular Java syntax and let JavaAssist translate it into bytecode and tack it on as a preamble to the method in question. Also, I've defined the method that gets attached in terms of a Spring Bean that the annotation references. This adds a convenient level of abstraction and indirection since the pre- and post-logic is defined in terms of a Spring Bean lookup key as opposed to the fully qualified class name of the code the developer wants to have executed before the business method's execution. &lt;br&gt;&lt;br&gt;Bringing It All Together&lt;br&gt;Last, but not least, I've put together some classes that implement what amounts to an interceptor pattern in our annotations-based aspect system. These classes are mainly for convenience and allow us to chain together pre- and post-method interceptors. They also showcase the generic and type-safe collections supported by Java 5.0. The following snippet is the declaration for an abstract base type called "BaseInterceptor": &lt;br&gt;&lt;br&gt;public abstract class BaseInjector{&amp;nbsp;&amp;nbsp; LinkedList &amp;lt;BaseInjector&amp;gt; injectors = new LinkedList ();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public BaseInjector( )&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; System.out.println("addding me");&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; injectors.add(this);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public BaseInjector( BaseInjector bi )&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;injectors.add(bi);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; public void executeChain(Object [] parameters )&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for( BaseInjector bi: injectors )&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bi.execute(parameters);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public abstract void execute(Object [] parameters);} // class BaseInjector&lt;br&gt;&lt;br&gt;"BaseInjector" holds a type-safe linked list of "BaseInjector" types. Recall the class that does the bytecode engineering and introduces method calls either before or after the annotated method. The code that's introduced during bytecode engineering is based on the "BaseInjector" class and is resolved at runtime via the Spring framework. So from a developer's perspective to introduce code that's executed either before a business method or after a business method, he or she would: &lt;br&gt;&lt;br&gt;Create a class (or classes) that extend "BaseInjector" and implement the execute() method. &lt;br&gt;Annotate the business methods you want instrumented specifying two parameters, the bean lookup key that Spring will use to build your interceptor and the 'pre' or 'post' specification that tells the bytecode engineering code where to tack this interceptor on. &lt;br&gt;Configure your Spring file. &lt;br&gt;Run the application with the appropriate command-line switches that properly run the agent prior to main being called and installs the class-file transformer. &lt;br&gt;For completeness, here's a snippet of the Spring configuration file that wires up the interceptor. Please note that it's possible to chain together interceptors; Spring will accommodate this quite nicely via its ability to reference other beans under its control and apply them in setters or constructor arguments. Please consult Spring's documentation for more information on this. In this context, the annotation would specify the "nullInjector" as the processBean attribute and either "pre" or "post" for the insertionPoint attribute that designates where the developer intends to have the code executed. &lt;br&gt;&amp;lt;!-- Null Injector --&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;bean id="nullInjector" class="injectors.NullInjector"&amp;nbsp;&amp;nbsp;singleton="false"&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;constructor-arg&amp;gt;&amp;lt;ref bean="interestingInjector"/&amp;gt;&amp;lt;/constructor-arg&amp;gt;&amp;lt;/bean&amp;gt;&lt;br&gt;At runtime, the injected code looks up the interceptor logic via Spring based on the value of the "processBean" attribute specified on the annotation being processed. Once retrieved, the injected code calls the "execute()" method on the bean that in turn executes whatever code happens to be in the "execute()" method. This pattern is fairly common in application server environments whereby the container must execute a series of interceptors either before or after the target business method. For instance, a J2EE container may do this on an EJB call to facilitate security, logging, statistics, and the like before actually executing the target method on the bean itself. &lt;br&gt;&lt;br&gt;Summary, Conclusion, and the Ubiquitous Product Disclaimer&lt;br&gt;There are some really notable inclusions in the latest release of Java. At the very minimum, developers should embrace generics as a way of making code safer and more readable. Generics also support a tighter contract between caller and service that's generally always a good thing. The annotation framework shows great promise for tool and framework writers. EJB 3.0 threatens to lean heavily on annotations and I suspect this may cause the pendulum of "xml configuration hell" to swing the other way. Developers will be able to introduce metadata closer to the source, which will eliminate the proliferation of deployment and runtime files that seem to be on the increase. Sun also seems to be inventing ways to open the JVM up a little to framework authors and tool builders; as evidence we've looked at some of the new hooks available to us for class loading and on-the-fly class manipulation. I encourage developers to poke around the "java.lang.annotations," the "java.lang.instrument," and the "java.lang.management" packages. It's this "poking around" that inspired some of the goodies in this article and the tiny framework that subsequently developed. &lt;br&gt;&lt;br&gt;I also encourage you to download, look at, hack, and run the source code available with this article. I've included pertinent snips of code, but the gist of this framework is best realized by looking at the entire landscape. &lt;br&gt;&lt;br&gt;Whoops, I almost forgot the product disclaimer. I wanted to make sure that I stated that this framework is a conceptual work and that I do not represent it as a full-blown aspect-oriented system. I feel the concepts here are viable and could be developed into a very rich, robust system but as set forth here are primarily intended as a backdrop to the new capabilities of Java. &lt;br&gt;&lt;br&gt;Copyright &amp;copy; 2005 SYS-CON Media. All Rights Reserved.&lt;br&gt;</content>
    <postId>2DC47FF7-C562-4080-AD61-A327B52FE4A0</postId>
    <pubDate>2005-06-28T00:00:00-04:00</pubDate>
    <title>Kicking the Tires on Java 5.0</title>
</post>
