<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>부기흡</author>
    <comments/>
    <content>Making PDFs Portable&lt;br&gt;&lt;br&gt;March 9, 2005&lt;br&gt;&lt;br&gt;Summary&lt;br&gt;&lt;br&gt;Since Adobe released the first public PDF Reference in 1993, a number of PDF utilities and libraries, supporting all kinds of languages and platforms, have been made available to users and developers alike. However, support for Adobe's technology has lagged in Java application development.&lt;br&gt;&lt;br&gt;By Ben Litchfield &lt;br&gt; &lt;br&gt;Since Adobe released the first public PDF Reference in 1993, a number of PDF utilities and libraries, supporting all kinds of languages and platforms, have been made available to users and developers alike. However, support for Adobe's technology has lagged in Java application development. And this is curious because PDF documents tend to be a popular way of storing and interchanging information when dealing with enterprise information systems - an application domain that Java technology is particularly well suited to. Yet it seems that, until recently, mature, capable PDF support wasn't readily available to Java applications developers. &lt;br&gt;&lt;br&gt;PDFBox (an Open Source project released under the BSD license) is a pure Java library that lets developers read and create PDF documents. It has features such as: &lt;br&gt;&lt;br&gt;Extracting text, including Unicode characters &lt;br&gt;Easy integration with text search engines like Jakarta Lucene &lt;br&gt;Encryption/Decryption of PDF documents &lt;br&gt;Importing/Exporting of form data in FDF and XFDF formats &lt;br&gt;Appending to existing PDF documents &lt;br&gt;Splitting a single PDF into multiple documents &lt;br&gt;Overlaying one PDF document on top of another &lt;br&gt;&lt;br&gt;PDFBox API&lt;br&gt;&lt;br&gt;PDFBox has been designed to represent PDF documents using familiar object-oriented paradigms. The data contained in a PDF document is a collection of basic object types: arrays, booleans, dictionaries, numbers, strings and binary streams. PDFBox captures these basic object types in the org.pdfbox.cos package (the COS Model). While it's possible to create any desired interactions with a PDF document using only these objects, it requires an intimate knowledge of the internals of PDF documents and the techniques used to represent higher-level concepts. For example, objects such as pages and fonts are represented as dictionaries with specialized attributes; deciphering all these various attributes and their types requires tedious consultation of the PDF Reference. &lt;br&gt;&lt;br&gt;For this reason, the org.pdfbox.pdmodel package (the PD Model) sits on top the COS Model and provides a high-level API that accesses PDF document objects in a more familiar manner (see Figure 1). Objects such as PDPage and PDFont can be found in this package, which encapsulates their lower-level COS model counterparts. &lt;br&gt;&lt;br&gt;A word of caution to developers: the PD Model offers many nice features but is still a work in progress. In some instances, use of the COS Model may be required to access a particular piece of PDF functionality. Consequently, all PD Model objects can retrieve the corresponding COS Model object that they represent, so it's always possible to start with the PD Model and drop down to the COS Model when the required piece of functionality is found to be missing. &lt;br&gt;&lt;br&gt;Now that the general capabilities of PDFBox have been discussed a few examples of its use are appropriate. We will start by reading an existing PDF document: &lt;br&gt;&lt;br&gt;PDDocument document = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PDDocument.load( "./test.pdf" );&lt;br&gt;&lt;br&gt;This operation will cause the PDF file to be parsed and an in-memory representation of the document will be created. To facilitate the efficient handling of large documents, PDFBox only stores the document structure in memory; objects such as images, embedded fonts and page content are cached in a temporary file. &lt;br&gt;&lt;br&gt;Note: When finished using a PDDocument object, care should be taken to invoke the close() method on the document object to release resources used during its creation. &lt;br&gt;&lt;br&gt;Text Extraction and Lucene Integration&lt;br&gt;&lt;br&gt;In an information retrieval age when applications are expected to have searching and indexing capabilities regardless of the medium, the ability to organize and catalog information into a searchable format is critical. This is simple for text and HTML documents, but PDF documents have more structure and meta-information that makes it difficult to extract the underlying text. The PDF language is similar to Postscript in that objects are drawn as vectors on the page at certain positions. For example: &lt;br&gt;&lt;br&gt;/Helv 12 Tf&lt;br&gt;0 13.0847 Td&lt;br&gt;(Hello World) Tj&lt;br&gt;&lt;br&gt;This set of instructions changes the font to Helvetica size 12, moves the caret to the next line and renders the string "Hello World." These command streams are usually compressed and the order in which the glyphs are displayed on the screen is not necessarily the order in which the characters appear in the file, so it isn't always possible to simply extract text strings directly from the raw PDF document. However, PDFBox has a sophisticated text-extraction algorithm that deals with this and other complexities, letting a developer get the text of the document as if reading off its rendered form. &lt;br&gt;&lt;br&gt;Lucene, which is part of the Apache Jakarta project, is a popular Open Source search engine library. Lucene lets developers create an index and do complex searches on a large volume of textual content based on that index. Since Lucene has adopted text as the common denominator for content, it's the developer's responsibility to convert the data contained in other desired file formats to text to use Lucene. For example, file formats such as Microsoft Word and StarOffice documents have to be converted to text before they can be added to a Lucene index. &lt;br&gt;&lt;br&gt;PDF files are no exception, but PDFBox makes it easy to include a PDF document in a Lucene index by supplying a special object that does the integration. A basic PDF document can be converted to a Lucene document with a single statement: &lt;br&gt;&lt;br&gt;Document doc = LucenePDFDocument.getDocument( file );&lt;br&gt;&lt;br&gt;This operation parses the PDF document, extracts the text and creates a Lucene document object that can then be added to the index. As mentioned above, PDF documents also contain metadata such as author information and keywords that are important to track when indexing PDF documents. Table 1 shows the fields that PDFBox will populate while creating the Lucene document. &lt;br&gt;&lt;br&gt;This integration makes it easy for developers to support simple searching and indexing of PDF documents with Lucene. Of course, some applications require more sophisticated text-extraction methods. In that case, the PDFTextStripper class can be used directly, or extended to handle these complex requirements. &lt;br&gt;&lt;br&gt;By extending this class and overriding the showCharacter() method, many aspects of text extraction can be controlled. For instance, an implementation of this method can use the x, y positioning information to limit the inclusion of certain blocks of text in the extraction. One use might exclude all of the text above a certain y-coordinate value effectively excluding an unwanted document header. &lt;br&gt;&lt;br&gt;Another example: Oftentimes a group of PDF documents may have been created from forms and the source data are no longer available. In other words, the documents all have some interesting text at similar locations on the page, but the form data used to fill the document out are no longer available. For example, a collection of cover letters that have the name and address at the same location in the document. In this case, an extension of the PDFTextStripper class can be used as a sort of screen-scraping device to extract the desired fields. &lt;br&gt;&lt;br&gt;Encryption/Decryption&lt;br&gt;&lt;br&gt;A popular PDF feature allows for encrypting document contents and setting access controls limiting who can view the unencrypted document. Specifically, a PDF document is encrypted with a master password and optionally a user password. If a user password has been provided, then a PDF reader such as Acrobat will prompt for a password before letting the document be viewed. The master password is required to change document permissions. &lt;br&gt;&lt;br&gt;The PDF specification lets creators of PDF documents restrict certain operations when viewing the PDF in Acrobat. Some of the available document restrictions are: &lt;br&gt;&lt;br&gt;Printing &lt;br&gt;Changing content &lt;br&gt;Extracting text &lt;br&gt;&lt;br&gt;A full explanation of PDF document security lies outside the bounds of this article and interested developers should reference the relevant sections of the PDF specification and evaluate its capabilities. The security model used in PDF documents is pluggable and lets different security handlers be employed when encrypting documents. As of this writing, PDFBox supports the "Standard" security handler, which is what most PDF documents use. &lt;br&gt;&lt;br&gt;To encrypt a document, it must first be assigned a security handler and then encrypted with a master password and user password. For example, the following code encrypts a document so a user can open it in Acrobat without entering a password (i.e., no user password), but can't print the document using the access control mechanism. &lt;br&gt;&lt;br&gt;//load the document&lt;br&gt;PDDocument pdf = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PDDocument.load( "test.pdf" );&lt;br&gt;//create the encryption options&lt;br&gt;PDStandardEncryption encryptionOptions = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new PDStandardEncryption();&lt;br&gt;encryptionOptions.setCanPrint( false );&lt;br&gt;pdf.setEncryptionDictionary( &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;encryptionOptions );&lt;br&gt;//encrypt the document&lt;br&gt;pdf.encrypt( "master", null );&lt;br&gt;//save the encrypted document &lt;br&gt;//to the file system&lt;br&gt;pdf.save( "test-output.pdf");&lt;br&gt;&lt;br&gt;For a more complete example, reference the source code for the encryption utility included in the PDFBox distribution: org.pdfbox.Encrypt. &lt;br&gt;&lt;br&gt;Many applications can generate PDF documents but don't allow control over the document's security options. PDFBox can be used here to intercept and encrypt the PDF before it's sent to the user. &lt;br&gt;&lt;br&gt;Form Integration&lt;br&gt;&lt;br&gt;When an application's output is a series of form field values, it is usually desirable to let the user save the form for record keeping. PDF technology is a great choice for this kind of output. A developer can write code to output PDF instructions manually to draw images, tables and text. Or encapsulate the data in XML and use an XSL-FO engine to create a PDF document. However, these approaches can be time-consuming, error-prone and inflexible. A better approach for simple forms might be to create a template and generate a filled-in document for any given set of input data based on the template. &lt;br&gt;&lt;br&gt;A form many of us may be familiar with is the Employment Eligibility Verification, or I-9 form: http://uscis.gov/graphics/formsfee/forms/files/i-9.pdf &lt;br&gt;&lt;br&gt;Using one of the example applications distributed with PDFBox, the form field names can be listed: &lt;br&gt;&lt;br&gt;java org.pdfbox.examples.fdf.PrintFields i-9.pdf&lt;br&gt;&lt;br&gt;Another example utility populates a given field with textual data: &lt;br&gt;&lt;br&gt;java org.pdfbox.examples.fdf.SetField i-9.pdf NAME1 Smith&lt;br&gt;&lt;br&gt;Opening the PDF document in Acrobat shows that the "Last Name" field has been filled in. This functionality can be recreated in code: &lt;br&gt;&lt;br&gt;PDDocument pdf = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PDDocument.load( "i-9.pdf" );&lt;br&gt;PDDocumentCatalog docCatalog = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pdf.getDocumentCatalog();&lt;br&gt;PDAcroForm acroForm = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;docCatalog.getAcroForm();&lt;br&gt;PDField field = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;acroForm.getField( "NAME1" );&lt;br&gt;field.setValue( "Smith" );&lt;br&gt;pdf.save( "i-9-copy.pdf" );&lt;br&gt;&lt;br&gt;It's also possible to extract the values of a form field that has been previously populated, as below: &lt;br&gt;&lt;br&gt;PDField field = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;acroForm.getField( "NAME1" );&lt;br&gt;System.out.println( &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"First Name=" + field.getValue() );&lt;br&gt;&lt;br&gt;Acrobat offers the option of exporting and importing form data in a special file format called "Forms Data Format." These files come in two flavors, FDF and XFDF. An FDF stores the form data in the same format as PDF, while XFDF stores data in XML format. PDFBox handles both FDF and XFDF data with a single object: FDFDocument. The following snippet shows how to export FDF data for the I-9 form above: &lt;br&gt;&lt;br&gt;PDDocument pdf = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PDDocument.load( "i-9.pdf" );&lt;br&gt;PDDocumentCatalog docCatalog = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pdf.getDocumentCatalog();&lt;br&gt;PDAcroForm acroForm = &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;docCatalog.getAcroForm();&lt;br&gt;FDFDocument fdf = acroForm.exportFDF();&lt;br&gt;fdf.save( "exportedData.fdf" );&lt;br&gt;&lt;br&gt;PDFBox Form Integration Steps &lt;br&gt;&lt;br&gt;Create PDF Form Template using Acrobat or other visual tool &lt;br&gt;Track the name of each desired form field &lt;br&gt;Store the template PDF where the application can access it &lt;br&gt;When the PDF is requested, use PDFBox to parse the template PDF &lt;br&gt;Populate the required form fields &lt;br&gt;Stream the PDF back to the user &lt;br&gt;Utilities&lt;br&gt;&lt;br&gt;Besides the library APIs mentioned above, PDFBox also has a set of command-line utilities. Table 2 lists the class name of each utility along with a short description. &lt;br&gt;&lt;br&gt;Remarks&lt;br&gt;&lt;br&gt;The PDF specification weighs in at 1,172 pages so implementing it is quite an undertaking. As such, PDFBox is distributed with the proviso that it is a work in progress, with new features being added over time. Its main weakness is in creating PDF documents from scratch. However, there are several other Open Source Java projects that can be used to fill the gap. For instance, the Apache FOP project lets programmers generate a PDF from a specialized XML document that describes the PDF document. Also, iText provides a high-level API for creating document elements such as tables and lists. &lt;br&gt;&lt;br&gt;The next version of PDFBox will add support for the new PDF 1.5 object stream and cross-reference streams. After that will be support for embedding fonts and images. Hopefully through efforts like PDFBox, robust support for PDF technology can be made available for Java applications. &lt;br&gt;&lt;br&gt;References&lt;br&gt;&lt;br&gt;&lt;br&gt;PDFBox: www.pdfbox.org/ &lt;br&gt;Apache FOP: http://xml.apache.org/fop/ &lt;br&gt;iText: www.lowagie.com/iText/ &lt;br&gt;PDF Reference: http://partners.adobe.com/asn/tech/pdf/specifications.jsp &lt;br&gt;Jakarta Lucene: http://jakarta.apache.org/lucene/ &lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</content>
    <postId>2CAF35E9-C824-45FF-8637-3A9EA8708ED5</postId>
    <pubDate>2005-03-23T00:00:00-05:00</pubDate>
    <title>Integrating PDF and Java Technology</title>
</post>
