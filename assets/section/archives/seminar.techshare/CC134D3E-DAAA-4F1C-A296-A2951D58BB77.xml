<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>부기흡</author>
    <comments/>
    <content>Tiger (J2SE 5.0) Tips: Auto-boxing and Auto-unboxing - 2 "Gotchas"&lt;br&gt;August 23, 2004&lt;br&gt;&lt;br&gt;Summary&lt;br&gt;&lt;br&gt;Following on from last week's exploration of the printf feature, Chakra Yadavalli this week examines the well publicized auto-boxing and auto-unboxing features of J2SE 5.0 (Tiger) and highlights two gotchas with regards to auto-boxing.&lt;br&gt;&lt;br&gt;By Chakra Yadavalli &lt;br&gt;&lt;br&gt;First, let's take another look at the printf snippet. &lt;br&gt;&lt;br&gt;If you are using the Eclipse 3.1M1 or Eclipse 3.0/Cheetah0.0.6 workspace, it would have probably given a compile error that the class java.io.PrintStream has no method that corresponds to printf(String, int, int, int). This is because the required Tiger features are not yet supported by Eclipse. However, our Ant build file successfully compiles the code as J2SE 5.0 provide a much convenient printf method that takes variable arguments.&lt;br&gt;&lt;br&gt;&lt;br&gt;int i = 0;&lt;br&gt;System.out.printf("%d %d %d", ++i, ++i, ++i);&lt;br&gt;// Eclipse 3.1M1 shows compile error.&lt;br&gt;&lt;br&gt;In order to understand how variable argument methods are declared, let's take a look at the Javadoc of printf. We see that the arguments to this method are defined as Object.... The ellipsis (...) denotes that there can be zero or more arguments of the specified type (in this case the type is java.lang.Object).&lt;br&gt;&lt;br&gt;&lt;br&gt;public PrintStream printf&lt;br&gt;(&lt;br&gt;String format, &lt;br&gt;&lt;br&gt;Object... args)&lt;br&gt;&lt;br&gt;A convenience method to write a formatted string to this output stream using the specified format string and arguments. &lt;br&gt;The goal of this article, however, is not to discuss the convenience (or inconvenience) of the variable arguments. That merits an article of its own. If you observe the printf snippet, you'll see that we are passing three primitive integers as the arguments and these are not subclasses of java.lang.Objects. In pre-Tiger versions of Java, if you try to use a primitive where java.lang.Object is expected (such as in Java Collections), you will get a compile time error. However, Tiger allows this with the help of its new feature called boxing/unboxing.&lt;br&gt;&lt;br&gt;So, What Is "Auto-boxing" Anyway?&lt;br&gt;The short answer is that it's the automatic conversion of the primitives to their corresponding Reference Types (AKA wrapper classes). And the converse is known as auto-unboxing. This allows for convenient use of primitives and the Reference types without having to code the annoying conversions. For example these features help in making the pre-Tiger code such as Integer x = new Integer(somePrimitiveInt) or int x = someIntegerClass.intValue() look more obvious and simple as follows: &lt;br&gt;&lt;br&gt;&lt;br&gt;Integer anInteger = 1234;&lt;br&gt;// boxing (Primitive to Wrapper)&lt;br&gt;int primInt = anInteger;&lt;br&gt;// unboxing (Wrapper to Primitive)&lt;br&gt;&lt;br&gt;Not only that, but it makes the arithmetic operations with the Wrapper classes look more easier to read. Translation: less typing on the programmer's part.&lt;br&gt;&lt;br&gt;&lt;br&gt;Integer anInteger = 1234;&lt;br&gt;int primInt = anInteger + 456;&lt;br&gt;Integer reminder = primInt % anInteger;&lt;br&gt;&lt;br&gt;So, do we have "operator overloading" in J2SE 5.0 (tiger)? Nope. We don't. Operator overloading has not been implemented in Java language because of the "gotchas" of languages such as C++. Though "convenient" to the programmers, features such as Default values for method arguments, Variable arguments for methods and operator overloading introduced more confusion than anything else. &lt;br&gt;&lt;br&gt;However, Tiger seems to provide support for some of these features directly (variable arguments) or indirectly. Instead of using operator overloading, Tiger uses boxing and unboxing to get the same effect with arithmetic and assignment operations (and comparison for Boolean wrappers). Auto-boxing and unboxing also make the method invocations (this would be the first gotcha with Tiger - discussed later) and storing primitives in collections much easier. &lt;br&gt;&lt;br&gt;Let's examine them up close and personal by creating a new class BoxIt with a generic method boxIt. This method basically does nothing. It takes an java.lang.Object as the argument, displays its type and value (string representation) and returns the argument itself.&lt;br&gt;&lt;br&gt;&lt;br&gt;package com.cyobjects.playwithtiger;&lt;br&gt;import java.util.logging.Level;&lt;br&gt;import static java.lang.System.out;&lt;br&gt;// New static import feature in Tiger.public class BoxIt {&lt;br&gt;&amp;nbsp;&amp;nbsp;public static Object boxIt(Object argObject){&lt;br&gt;&amp;nbsp;&amp;nbsp;out.printf("boxIt: Object type = %s value = %s%n",&lt;br&gt;&amp;nbsp;&amp;nbsp;argObject.getClass().getName(), argObject);&lt;br&gt;&amp;nbsp;&amp;nbsp;return argObject;&lt;br&gt;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;nbsp;public static void main(String[] args) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boxIt(10); // Primitive int&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boxIt(1.234f); // Primitive float&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boxIt(1.234d); // Primitive double&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boxIt(10l); // Primitive long&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boxIt('C'); // Primitive char&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boxIt(true); // Primitive boolean&lt;br&gt;&amp;nbsp;&amp;nbsp;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;First, a short note on the line import static java.lang.System.out;. This is the new static import feature of Tiger that allows importing on ONLY the static members defined in a class. The goal of this feature is (just as you guessed) convenience. However, I think it adds more confusion to the code even though it helps in preventing the export of implementation details as in the case with Constant Interface Antipattern. The reason I point this is out now is that recently I attended a JUG meeting in which someone asked the presenter what is out in a statement out.printf("blah"); and there was no answer! &lt;br&gt;&lt;br&gt;Anyways, in order to compile/execute this code, add the following Ant task to our build.xml.&lt;br&gt;&lt;br&gt;&lt;br&gt;&amp;lt;target name="boxit"&lt;br&gt; description="runs the BoxIt program" depends="compile"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;lt;java classname="com.cyobjects.playwithtiger.BoxIt" fork="true"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;classpath refid="project.class.path" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;lt;/java&amp;gt;&lt;br&gt;&amp;lt;/target&amp;gt;&lt;br&gt;&lt;br&gt;Now, run the Ant build by selecting the "Run &amp;gt; Ant Build.." option from build.xml file's context menu. Make sure you select the "boxit" task in the Ant build launch configuration. A successful compile and execution of the code should give the following output in the Console view.&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] boxIt: Object type = java.lang.Integer value = 10&lt;br&gt;[java] boxIt: Object type = java.lang.Float value = 1.234&lt;br&gt;[java] boxIt: Object type = java.lang.Double value = 1.234&lt;br&gt;[java] boxIt: Object type = java.lang.Long value = 10&lt;br&gt;[java] boxIt: Object type = java.lang.Character value = C&lt;br&gt;[java] boxIt: Object type = java.lang.Boolean value = true&lt;br&gt;&lt;br&gt;Boxing and the printf Snippet&lt;br&gt;So far, boxing is pretty nice and simple. But how is this related to the printf snippet? &lt;br&gt;Well, when the java.io.PrintStream.printf(String, Object...) method is invoked with the three ++i's, i is incremented, then boxed into java.lang.Integer (for three separate times) and then the three boxed java.lang.Integer wrapper objects are passed to the printf method. As the wrappers are subclasses of java.lang.Object, they match with the printf variable argument method signature. The printf method then formats them using the format string to display the result. So, the Java version of printf also has more that goes under the covers. &lt;br&gt;&lt;br&gt;Another quick note about printf. Its output is same as that of format (see javadoc) and both these methods internally use the new java.util.Formatter to create the string that is displayed on the standard output. One thing that caught my attention in the Formatter is that it uses java.lang.StringBuilder. The StringBuilder is a new class added in Tiger. It works/looks just like java.lang.StringBuffer. The only difference is that StringBuilder isn't synchronized and so is thread-unsafe - meaning, the programmer should ensure that only one thread can modify an instance. &lt;br&gt;&lt;br&gt;On the other hand, StringBuffer, which has been "advertised" (until now) as a high performance substitution for String concatenation (using +) is implemented as thread-safe. So, the new StringBuilder helps in making string concatinations 20 times (?) faster by avoiding the uncontended synchronization overhead. The new StringBuilder and the old StringBuffer have a common "package visible" abstract base class AbstractStringBuilder. Thus, changing the existing code that uses StringBuffer to use StringBuilder should be a matter of CTRL+h (find/replace). The new hierarchy is shown as below. &lt;br&gt;&lt;br&gt;On a different note, the lesson learnt from this is that premature synchronization is never good. It only results in performance overhead and more refactoring. If you feel that synchronization is not needed in some cases, implement an unsynchronized version of the class and think of implementing the thread-safe functionality as a Synchronization Wrapper using GOF Decorator Pattern. You may also want to consider pulling up the common methods into an abstract class or interface.&lt;br&gt;&lt;br&gt;&lt;br&gt;abstract class AbstractStringBuilder&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;implements Appendable, CharSequence&lt;br&gt;public final class StringBuffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;extends AbstractStringBuilder&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;implements java.io.Serializable, CharSequence&lt;br&gt;public final class StringBuilder&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;extends AbstractStringBuilder&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;implements java.io.Serializable, CharSequence&lt;br&gt;&lt;br&gt;Our First Tiger "Gotcha"&lt;br&gt;Looks like we are wandering off topic so let's confine our wandering just to the "boxing ring." Earlier I mentioned that the boxing happens in the assignments, arithmetic expressions and method invocations. And that there is one "gotcha" with method invocations. Take a look at the following code and see which method will be called. &lt;br&gt;&lt;br&gt;&lt;br&gt;// add the following code to our BoxIt class.&lt;br&gt;public static void someOverloadedMethod(int argInt){&lt;br&gt;&amp;nbsp;&amp;nbsp;out.printf("In someMethod(int) with type: %s %d%n",&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int.class.getName(), argInt);&lt;br&gt;&lt;br&gt;}&lt;br&gt;public static void someOverloadedMethod(Object argObject){&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.printf("In someMethod(Object) with type: %s value:%s%n",&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; argObject.getClass().getName(), argObject);&lt;br&gt;}&lt;br&gt;&lt;br&gt;// change the main method of BoxIt to the following&lt;br&gt;public static void main(String[] args) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer intWrapper = 1234;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int intPrim = 4567;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object anObjectWithBoxedInteger = 7890;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;someOverloadedMethod(intWrapper);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;someOverloadedMethod(10);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;someOverloadedMethod(anObjectWithBoxedInteger);&lt;br&gt;}&lt;br&gt;&lt;br&gt;The output shows that it is same as the output of the pre-Tiger code (backward compatibility with legacy code). So, here, boxing or unboxing did not happen and thus someOverloadedMethod(intWrapper) did not call someOverloadedMethod(int).&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] In someMethod(Object) with type: java.lang.Integer value:1234&lt;br&gt;[java] In someMethod(int) with type: int 10&lt;br&gt;[java] In someMethod(Object) with type: java.lang.Integer value:7890&lt;br&gt;&lt;br&gt;Let's see what happens when we add another overloaded version of someOverloadedMethod to the mix. What would be the output of above main method when the following code is added to BoxIt?&lt;br&gt;&lt;br&gt;&lt;br&gt;public static void someOverloadedMethod(Integer argInteger){&lt;br&gt; out.printf("In someMethod(Integer) with type: %s value:%s%n",&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; argInteger.getClass().getName(), argInteger);&lt;br&gt;}&lt;br&gt;&lt;br&gt;The output would be as follows. Though the anObjectWithBoxedInteger has an integer inside it, overloading uses static binding rather than dynamic binding (which is the mechanism for overriding). So the someOverloadedMethod(Integer) is not called when we invoke the method with anObjectWithBoxedInteger which is declared as java.lang.Object. This is not something new in Tiger. So, overloading methods like this is not good. It is hardly necessary to say, one should not write this kind of code.&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] In someMethod(Integer) with type: java.lang.Integer value:1234&lt;br&gt;[java] In someMethod(int) with type: int 10&lt;br&gt;[java] In someMethod(Object) with type: java.lang.Integer value:7890&lt;br&gt;&lt;br&gt;Boxing in Comparision&lt;br&gt;As mentioned earlier, boxing applies only to the java.lang.Boolean wrappers in evaluating expressions involving logical operators -- AND (&amp;&amp;), OR(||) NOT (!). So, the following code would be perfectly alright in Tiger and prints The condition evaluates to false. &lt;br&gt;&lt;br&gt;&lt;br&gt;Boolean aBoolean = true;&lt;br&gt;Boolean anotherBoolean = false;&lt;br&gt;if (aBoolean &amp;&amp; anotherBoolean){&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.println("The condition evaluates to true");&lt;br&gt;} else {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.println("The condition evaluates to false");&lt;br&gt;}&lt;br&gt;&lt;br&gt;Again, Tiger supports this "pseudo" operator overloading with boxing. The "if" condition is evaluated by first unboxing the aBoolean and anotherBoolean into primitive booleans. Then the values are compared and evaluated. The following code also uses the same mechanism.&lt;br&gt;&lt;br&gt;&lt;br&gt;boolean result = !(aBoolean&lt;br&gt;|| anotherBoolean) &amp;&amp;&lt;br&gt;yetAnotherBoolean;&lt;br&gt;&lt;br&gt;What about comparison - EQUALS (==) and NOT EQUALS (!=)? Yes, we can "safely" use Boolean wrappers in comparison. The following code is perfectly alright in Tiger and prints Yup, they are one and the same..&lt;br&gt;&lt;br&gt;&lt;br&gt;Boolean aBoolean = true;&lt;br&gt;Boolean anotherBoolean = true;&lt;br&gt;if (aBoolean == anotherBoolean){&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.printf("Yup, they are one and the same.%n");&lt;br&gt;} else {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.printf("Nope, they are not one and the same.%n");&lt;br&gt;}&lt;br&gt;&lt;br&gt;The above code could raise some (eyebrows and) red flags in pre-Tiger code. What? You are comparing object handles rather than using equals? Yes. Tiger allows us to do that. As boolean has only two values, true and false, internally the JVM caches these Boolean wrappers as "indistinguishable" objects. Thus, these booleans refer to the same objects. Changing the anotherBoolean to false would result in the output Nope, they are not one and the same. But, the important point here is that there is no unboxing involved in evaluating the comparison.&lt;br&gt;&lt;br&gt;Our Second Tiger "Gotcha"&lt;br&gt;It's about time we added more code to our BoxIt class. Let's add another generic method compareReferences method that takes two Objects and compares their handles. &lt;br&gt;&lt;br&gt;&lt;br&gt;public static boolean compareReferences(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object anObject, Object anotherObject) {&lt;br&gt;out.printf("compareReferences: Object types anObject: %s anotherObject = %s%n",&lt;br&gt;anObject.getClass().getName(), anObject.getClass().getName());&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.printf("compareReferences: Comparing %s and %s.%n",&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; anObject, anotherObject);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (anObject == anotherObject) {&lt;br&gt;out.printf("compareReferences: Yup, they are one and the same.%n");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br&gt;out.printf("compareReferences: Nope, they are not one and the same.%n");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return (anObject == anObject);&lt;br&gt;}&lt;br&gt;&lt;br&gt;And invoke this method with the following code from the BoxIt's main method. And before executing the "boxit" Ant task, take a guess on what would be printed by the first and second invocation of compareReferences method.&lt;br&gt;&lt;br&gt;&lt;br&gt;Integer anInteger = 1234;&lt;br&gt;Integer anotherInteger = 1234;&lt;br&gt;compareReferences(anInteger, anotherInteger);&lt;br&gt;anInteger = anInteger - 1200;&lt;br&gt;anotherInteger = anotherInteger - 1200;&lt;br&gt;compareReferences(anInteger, anotherInteger);&lt;br&gt;&lt;br&gt;Execute "boxit" Ant task and see the output of first call to compareReferences.&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] compareReferences: Object types anObject:&lt;br&gt;java.lang.Integer anotherObject = java.lang.Integer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [java] compareReferences: Comparing 1234 and 1234.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [java] compareReferences: Nope, they are not one and the same.&lt;br&gt;&lt;br&gt;Unlike the Boolean, the comparison failed as the anInteger and anotherIntegerare different objects and therefore, evaluate to different references. However, the output of the second call to compareReferences takes us by surprise. What?! They are one and the same? How come?&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] compareReferences: Object types anObject:&lt;br&gt;java.lang.Integer anotherObject = java.lang.Integer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [java] compareReferences: Comparing 34 and 34.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [java] compareReferences: Yup, they are one and the same.&lt;br&gt;&lt;br&gt;In order to understand this, we need to dig into the specifications and see what other nuances they have got to offer. Autoboxing is covered in JSR 201: Extending the JavaTM Programming Language with Enumerations, Autoboxing, Enhanced for loops and Static Import. I suggest you download and read some of these JSRs. It is a one-time expense of time/effort but will result in good ROI. If you download current Proposed Draft2, you will find about 8 chapters of the new JLS 3.0 in the folder jsr201-pfd2/jls3-chapters-jsr201. The following is a quote from Chapter 5: Conversions:&lt;br&gt;&lt;br&gt;reference: Section 5.1.7 Boxing Conversions&lt;br&gt;"If the value p being boxed is true, false, a byte, a char in the range \\u0000 to \\u007f, or an int or short number between -128 and 127, then let r1 and r2 be the results of any two boxing conversions of p. It is always the case that r1 == r2."&lt;br&gt;&lt;br&gt;reference: Discussion&lt;br&gt;"Ideally, boxing a given primitive value p, would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rules above are a pragmatic compromise. The final clause above requires that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. &lt;br&gt;&lt;br&gt;For other values, this formulation disallows any assumptions about the identity of the boxed values on the programmer's part. This would allow (but not require) sharing of some or all of these references. &lt;br&gt;&lt;br&gt;This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all characters and shorts, as well as integers and longs in the range of -32K - +32K."&lt;br&gt;&lt;br&gt;The second call to compareReferences method is done with two integer wrappers that evaluate to the int value 34. By the above r1 == r2 principle, as -128 &amp;lt; 34 &amp;lt; 127, both the anInteger and anotherInteger objects resolve to same references of cached "indistinguishable" object. Therefore the surprise. Gotcha! &lt;br&gt;&lt;br&gt;This is another good reason why writing code that compares references is not advised. But one thing that caught my attention is the statement about "Less memory-limited" implementations. Given all the "performance ergonomics" of HotSpot that lets the JVM automatically start in the server mode on machines with enough RAM, I thought I would try to find what range of integers are cached on my machine using Sun JDK 1.5. So, wrote a simple cacheTestIntegers method in the BoxIt as follows:&lt;br&gt;&lt;br&gt;&lt;br&gt;public static void cacheTestIntegers() {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer anInteger = -32 * 1024;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer anotherInteger = -32 * 1024;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int counter = -32 * 1024;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int cacheStart = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int cacheEnd = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean cacheStartFound = false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (counter &amp;lt;= 32 * 1024) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (anInteger == anotherInteger) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!cacheStartFound) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cacheStart = counter;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cacheStartFound = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (cacheStartFound) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cacheEnd = counter - 1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++counter;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++anInteger;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++anotherInteger;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.printf("cacheTestIntegers: JVM vendor: %s version: %s.%n",&lt;br&gt;System.getProperty("java.vendor"), System.getProperty("java.version"));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.printf("cacheTestIntegers: Caches *indistinguishable* boxed " +&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"Integers from %d to %d (both values inclusive).",&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cacheStart, cacheEnd);&lt;br&gt;}&lt;br&gt;&lt;br&gt;The output prints the JVM vendor, version and the range of integers that are cached as "indistinguishable" objects. The following is printed on my machine. It would be interesting to see what would be the output in a micro edition of Tiger. Did anyone try this? If so, please leave a comment below with the output. I also searched if IBM JDK is available. But the developerWorks Web site says that it will only be available in 2005. I even sent an e-mail to IBM UK research (the JVM Cookbook guys) but they said they don't have a preview version yet. But the gentleman replied "As to your specific JIT questions, I'll pass them on and see if the team can comment." I haven't heard from them yet. If I do, you will be the first to know.&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] cacheTestIntegers: JVM vendor: Sun Microsystems Inc. version: 1.5.0-beta2.&lt;br&gt;[java] cacheTestIntegers: Caches *indistinguishable* boxed Integers from&lt;br&gt;-128 to 127 (both values inclusive).&lt;br&gt;&lt;br&gt;Well, well, well. The things we do to stay platform-independent, yet still have good performance while being convenient to the LCD developer. One might say, the concept of caching these wrappers is similar to that of the java.lang.String literal nuance. Let's execute our compareReferences with string objects. Take a guess what would be the output.&lt;br&gt;&lt;br&gt;&lt;br&gt;String aString = "Chakra Yadavalli";&lt;br&gt;String anotherString = "Chakra Yadavalli";&lt;br&gt;compareReferences(aString, anotherString);&lt;br&gt;aString = aString + "";&lt;br&gt;anotherString = anotherString + "";&lt;br&gt;compareReferences(aString, anotherString);&lt;br&gt;&lt;br&gt;The first call to compareReferences uses String literals with the same value. Thus they point to the same object and have the same reference. However, the second call uses modified String objects (though with the same value) and thus evaluates to different references resulting in the output shown below.&lt;br&gt;&lt;br&gt;&lt;br&gt;[java] compareReferences: Object types anObject:&lt;br&gt;java.lang.String anotherObject = java.lang.String&lt;br&gt;[java] compareReferences: Comparing Chakra Yadavalli and Chakra Yadavalli.&lt;br&gt;[java] compareReferences: Yup, they are one and the same.&lt;br&gt;[java] compareReferences: Object types anObject:&lt;br&gt;java.lang.String anotherObject = java.lang.String&lt;br&gt;[java] compareReferences: Comparing Chakra Yadavalli and Chakra Yadavalli.&lt;br&gt;[java] compareReferences: Nope, they are not one and the same.&lt;br&gt;&lt;br&gt;But the wrapper caching would result in the same references to the cached objects if the values are changed by say, arithmetic operations. So, unlike its String counterpart, the following code would print Yup, they are one and the same. for both calls to compareReferences&lt;br&gt;&lt;br&gt;&lt;br&gt;Integer anInteger = 123;&lt;br&gt;Integer anotherInteger = 123;&lt;br&gt;compareReferences(anInteger, anotherInteger);&lt;br&gt;anInteger = anInteger + 1;&lt;br&gt;anotherInteger = anotherInteger + 1;&lt;br&gt;compareReferences(anInteger, anotherInteger);&lt;br&gt;&lt;br&gt;So, the Moral of the Story is...&lt;br&gt;Don't overload methods that are confusing to the programmers (i.e., humans). &lt;br&gt;Don't compare the object references at any point to check the equality of the objects (unless it is a special case and requires reference comparison). Instead, use the appropriate .equals(Object) method. &lt;br&gt;Look out for the reference comparisons in code reviews. Use bug pattern detector tools such as FindBugs! stand-alone or Eclipse plugin to find references comparisons and incompatible declarations of .equals() method. &lt;br&gt;Use the @Override annotation while declaring the .equals(Object) method to ensure that it generates a compile time error if the signature does not match with the java.lang.Object's declaration (or your object's super class) &lt;br&gt;Last but not least, don't trust the hairs on the back of your neck. Rather, rely on the good old proven principle -- RTFM! &lt;br&gt; &lt;br&gt;&lt;br&gt;</content>
    <postId>CC134D3E-DAAA-4F1C-A296-A2951D58BB77</postId>
    <pubDate>2004-08-24T00:00:00-04:00</pubDate>
    <title>Tiger (J2SE 5.0) Tips: Auto-boxing and Auto-unboxing - 2 "Gotchas"</title>
</post>
