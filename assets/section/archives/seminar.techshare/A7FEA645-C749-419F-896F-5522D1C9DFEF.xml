<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<post>
    <author>부기흡</author>
    <comments/>
    <content>About Duncan Jack&lt;br&gt;&lt;br&gt;Duncan Jack started the Scottish CFUG (www.scottishcfug.com), which is now ably run by Andy Allan. Duncan recently founded Scottish Java (www.scottishjava.com), a brand new Java community. A Macromedia Certified Flash MX 2004 Developer, his main interests are in building innovative Rich Internet Applications using Flash, Flex, ColdFusion and JRun. An accomplished mountaineer, he holds a first-class honours degree in Civil Engineering and is currently studying for an M.Sc. in Advanced Computer Science.&lt;br&gt;===========================================&lt;br&gt;&lt;br&gt;Over the past 12 months, I have observed significant benefits using the Unified Modeling Language (UML) when developing Rich Internet Applications using Macromedia's Flash Platform and JRun (Java application server). &lt;br&gt;&lt;br&gt; This article first discusses what the UML is, then lists some of the main diagram types. It highlights how these diagrams can be used and draws attention to some of the benefits I've observed when using them. It concludes with a list of resources. &lt;br&gt;&lt;br&gt;What Is the Unified Modeling Language&lt;br&gt;To understand the essence of the UML, consider the elements of its name: &lt;br&gt;&lt;br&gt;Unified: The result of unifying three leading approaches to system modelling in the 1990s &lt;br&gt;&lt;br&gt;Modeling: concerned with the simplified representation of system structure and behavior &lt;br&gt;&lt;br&gt;Language: A language, not a methodology &lt;br&gt;&lt;br&gt;The UML provides a language-neutral, tool-supported, well-documented standard for modeling systems such as Web applications. It enables system requirements, structure, and behavior to be succinctly captured and effectively communicated. &lt;br&gt;At the time of writing this article, the UML 2.0 Specification is going through final editing, although you'll find that many books and tools support at least a subset of this specification. A draft version of the specification is available on the Object Management Group's UML Web site. Helpful note - don't try and learn the UML from this document, but it can make interesting reading! &lt;br&gt;&lt;br&gt;The UML is not a methodology. This point is important. Some people think that you have to use every diagram type to model every aspect of system behavior all the time as part of a complex, cumbersome approach. Not at all. Simply make intelligent choices about what works for you. The UML is designed to serve you, not the other way around. &lt;br&gt;&lt;br&gt;To illustrate this point, consider the Java programming language. Java is a language, not a methodology. To derive full benefit from your use of Java, you adopt an effective methodology. You may adapt your approach on different projects. You use a subset of Java to build an application. You don't try and use every feature of the language in every application you build. &lt;br&gt;&lt;br&gt;In the same way, blend the UML into the successful methodology you already use. &lt;br&gt;&lt;br&gt;Main Diagram Types&lt;br&gt;Essentially, when you use the UML, you draw diagrams and add notations to them. You may draw a UML diagram by hand on the back of a menu over lunch with a client or on a whiteboard. Equally, you may use a tool such as MagicDraw UML. &lt;br&gt;&lt;br&gt;There are two main categories of UML diagrams defined by the UML 2.0 Specification: &lt;br&gt;&lt;br&gt;Structure Diagrams (six): Concerned with modeling static structure (architecture) &lt;br&gt;&lt;br&gt;Behavior Diagrams (seven): Concerned with modeling dynamic behavior &lt;br&gt;I have found the following diagrams most useful since I began using the UML 12 months ago: &lt;br&gt;Use Case Diagram (behavior) &lt;br&gt;Activity Diagram (behavior) &lt;br&gt;Class Diagram (structure) &lt;br&gt;Sequence Diagram (behavior) &lt;br&gt;Using these four diagrams in sequence has been very effective, so I will address each in turn. &lt;br&gt;Use Case Diagram&lt;br&gt;Use case diagrams help to define the requirements of a system from the user's perspective - what they want to achieve when using the system. &lt;br&gt;&lt;br&gt;The use case diagram is deceptively simple yet incredibly powerful. Notes are added to the diagram, and may of course be supplemented by other documents where appropriate. This is exactly what architects and engineers in other disciplines do too, of course - use blueprints and drawings. &lt;br&gt;&lt;br&gt;The user may be a human object or software object (if you are developing a Web service in Java for example). The basic syntax is very simple (see Figure 1). &lt;br&gt;&lt;br&gt;As you can see from the diagram in Figure 1, the system is required to let a user check availability and book a ticket. Notice that the diagram does not go into the detail of how this will be accomplished. It helps them focus on desired outcomes and not the process. For me, that's the power of use case diagrams - focusing minds and drawing out detail. Of course, it's important to remember that clients may: &lt;br&gt;&lt;br&gt;Not know exactly what they want or need. &lt;br&gt;Be reporting to a boss who has given them unclear, incorrect, and incomplete requirements. &lt;br&gt;Be part of a wider team among which requirements are fragmented. &lt;br&gt;Forget or contradict their own requirements. &lt;br&gt;I have noticed a number of business benefits when using use case diagrams. It's the simplicity of the diagram and the practice of going through the process with a client that really pays off. I've noticed that these diagrams help to: &lt;br&gt;Discover what clients actually want and need &lt;br&gt;Draw in other stakeholders (the boss, co-workers, etc.) to the requirements gathering process on an ongoing basis &lt;br&gt;Identify any correct and contradiction in requirements &lt;br&gt;I was recently involved in a project to build a Rich Internet Application for a business run by three extremely capable directors in their 50s. They found the use case diagram indispensable. At every meeting, the first thing we would do was review it, to confirm that all requirements had been captured and were fully up to date. &lt;br&gt;As additional requirements were identified, these were either added into the current version or added to a list for future discussion. Either way, it was up to the clients to decide. The use case diagram was a living, breathing document that provided an ideal way to ensure that the interface with the clients remained cohesive. &lt;br&gt;&lt;br&gt;Letting them each have a copy of the diagram that they could mark up and use in their own internal meetings proved to be a very effective way to draw everybody in and ensure we built the right system. &lt;br&gt;&lt;br&gt;We became a natural extension of their business; they became a natural extension of our project team. As a result, meetings were more productive, a better application was delivered more quickly, and business was stored up for the future. In addition, our approach helped us to differentiate ourselves from our competition and ensure a strong ongoing relationship with the clients.&lt;br&gt;&lt;br&gt;&lt;br&gt;Activity Diagram&lt;br&gt;Once the requirements of a system from the users' perspective have been defined, activity diagrams help to define how this user experience will be achieved. &lt;br&gt;&lt;br&gt;Activity diagrams are also extremely powerful. They are well suited to fleshing out the details of a use case by modeling the detailed interaction between a user and a system or screen. Activity diagrams are used to model: &lt;br&gt;&lt;br&gt;Business processes. &lt;br&gt;Flow of control in an executing program. &lt;br&gt;Details of a method. &lt;br&gt;They are a close relative of the traditional flowchart (see Figure 2). As you identify and diagram the different activities, you'll naturally see a pattern of objects emerge to which the different activities can be assigned. You can use the swim lanes to assign responsibilities to different objects - whether those objects are people or software. &lt;br&gt;Class Diagram&lt;br&gt;Class diagrams are used to model the classes of objects in a system (people and software). In the context of this article, the software building blocks are likely to be Java classes. &lt;br&gt;&lt;br&gt;Think of a class - it has properties (attributes and associations) and methods and can be represented as shown in Figure 3. &lt;br&gt;&lt;br&gt;The Order class has an orders property, which is an array of order items, each one represented by an OrderItem object. Although this could simply have been shown as an attribute inside the class, it's often more meaningful to represent such a property using an association as above. &lt;br&gt;&lt;br&gt;On this point, I found Martin Fowler's excellent book, UML Distilled, particularly helpful. I highly recommend it. He goes into class diagrams in some detail and wisely splits his coverage into two chapters, focusing the first chapter on the essentials. &lt;br&gt;&lt;br&gt;Class diagrams seem to follow so naturally from activity diagrams; the activities identified often may neatly correspond to methods in a class diagram, which helps save time and increase productivity. &lt;br&gt;&lt;br&gt;There is, of course, no requirement to identify every property or method on a class in a class diagram. You may choose to show only public methods for example. Equally, you don't have to show all classes and relationships between them. Again, use what works for you. &lt;br&gt;&lt;br&gt;Class diagrams really help when architecting the system and seem to give the design "room to breathe." It seems that if the design is elegant, the implementation is elegant too. If the implementation is elegant, it can be more pleasurable and cost-effective to evolve and maintain on an ongoing basis once the system has been put into production. &lt;br&gt;&lt;br&gt;In Ian Sommerville's definitive work, Software Engineering, he cites (and qualifies) research that suggests up to 90% of software costs are evolution costs. Looking at this another way, if all you build for a client is the initial implementation of a system, you may only be getting as little as 10% of the revenue stream that you would otherwise get from that client over the lifetime of the system. Of course, these figures will vary significantly, but it's an interesting thought. &lt;br&gt;&lt;br&gt;If you build a system that can be evolved elegantly and cost effectively, you're more likely to keep the relationship with the client, give them a better service, and make more money. Class diagrams are great for organizing where functionality will go, and for helping to select consistent and meaningful property and method names. &lt;br&gt;&lt;br&gt;Sequence Diagram&lt;br&gt;Have you ever developed an application and then had to come back and modify it six months later and tried to work out how on earth you did it? Well, the UML sequence diagram may be able to help you. &lt;br&gt;&lt;br&gt;A sequence diagram models the sequence of interactions between objects. In some ways, it a close cousin of an activity diagram, yet focused more on the behavior of software objects on a timeline (see Figure 4). &lt;br&gt;&lt;br&gt;Sequence diagrams are great for thinking through a design, illustrating an idea, and also getting back up to speed when changes need to be made six months or so after the system has gone into production. The design stands out so clearly. &lt;br&gt;&lt;br&gt;Prior to finding out about the UML, I used my own non-standard diagrams. For me, the biggest single benefit of the UML has been the sequence diagram. &lt;br&gt;&lt;br&gt;In the UML modeling tool I use, MagicDraw UML, I typically have a class diagram open at the same time as a sequence diagram. As I work on the design and identify additional methods, I add these to the appropriate class. These methods are then immediately available for me in the sequence diagram. As a result, it's much easier to create an elegant design and enhance productivity. Another powerful feature of MagicDraw UML is that it enables me to generate all the framework code in Java from the UML model at the click of a button (equally, I can reverse engineer a sequence diagram from Java code). &lt;br&gt;&lt;br&gt;It also ensures that the design is the documentation, which ensures that the documentation is done as the design evolves, changing with it. The appropriate use of annotated UML diagrams can save time, which is a significant business benefit. &lt;br&gt;&lt;br&gt;In addition, it becomes a pleasure to come back and add additional functionality at a later date. &lt;br&gt;&lt;br&gt;Getting Started with the UML&lt;br&gt;Here's what worked for me and what I generally suggest to anyone interested in getting started: &lt;br&gt;&lt;br&gt;Get a tool such as MagicDraw UML (free community edition and trial available). Tools have a lot of intelligence built in, which helps you get up to speed quickly on a couple of diagram types. The tool knows the specification. Have a look at the various symbols available in one or two of the main diagram types described above. Start using some of the symbols; you don't have to use them all. Grow into the tool over time. Learn the structure of the documentation and start reading it. &lt;br&gt;Get Martin Fowler's book, UML Distilled. Read it a couple of times. It's a great book, aptly titled. I found Martin's real-world experience and balanced view of using the UML very helpful. &lt;br&gt;Remember that the UML is a language, not a methodology, so don't think you have to change everything you already do successfully in order to get started with the UML. Take it one diagram at a time. Used effectively, the UML offers significant benefits. &lt;br&gt;Resources &lt;br&gt;&lt;br&gt;MagicDraw UML (includes comprehensive documentation and examples): www.magicdraw.com &lt;br&gt;Fowler, M. (1999). UML Distilled. Addison-Wesley: www.pearsoned.co.uk/Bookshop/ &lt;br&gt;Sommerville, I. (2004). Software Engineering 7. Addison Wesley: www.pearsoned.co.uk/Bookshop/ &lt;br&gt;UML 2.0 Specification and useful links: www.uml.org &lt;br&gt;&lt;br&gt;&amp;copy; 2005 SYS-CON Media Inc. &lt;br&gt;</content>
    <postId>A7FEA645-C749-419F-896F-5522D1C9DFEF</postId>
    <pubDate>2005-08-12T00:00:00-04:00</pubDate>
    <title>Observed Benefits of the Unified Modeling Language</title>
</post>
